<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>🔥基于taro + dva + typescript 开发的音乐播放器小程序</title>
      <link href="/2019/01/11/taro-music/"/>
      <url>/2019/01/11/taro-music/</url>
      
        <content type="html"><![CDATA[<h1>简介</h1><p>本项目是基于 <a href="https://github.com/NervJS/taro" target="_blank" rel="noopener">Taro</a> + <a href="https://dvajs.com/" target="_blank" rel="noopener">Dva</a> + <a href="https://www.tslang.cn/index.html" target="_blank" rel="noopener">TypeScript</a> 开发的音乐播放器小程序，是个人用于学习taro框架开发的，功能也相对简单，当然也存在一些不足，前期是用taro的redux版本开发，后面发现业务代码和页面耦合度高，就加入了dva，一个基于 <a href="https://github.com/reduxjs/redux" target="_blank" rel="noopener">redux</a> 和 <a href="https://github.com/redux-saga/redux-saga" target="_blank" rel="noopener">redux-saga</a> 的数据流方案，这里只用了dva的一个核心 <a href="https://github.com/dvajs/dva/tree/master/packages/dva-core" target="_blank" rel="noopener">dva-core</a>，用于model层来降低耦合，用 <a href="https://github.com/dvajs/dva-model-extend" target="_blank" rel="noopener">dva-model-extend</a> 复用 model，大大提升了开发体验，效果不错。后台是网易云音乐<a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/" target="_blank" rel="noopener">NeteaseCloudMusicApi</a> 提供的API，目前该项目还没有正式上线到小程序。</p><a id="more"></a><div align="center"><img src="https://github.com/huangzhuangjia/taro-music/blob/master/src/assets/image/music.gif?raw=true)](https://github.com/huangzhuangjia/taro-music/blob/master/src/assets/image/music.gif?raw=true" alt="gif"></div><h1>Usage</h1><blockquote><p>本项目已经使用了线上api接口，所以无需运行后台也可以获取数据，当然你也可以在本地运行 <a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/" target="_blank" rel="noopener">NeteaseCloudMusicApi</a> 项目，开启获取歌曲服务，默认端口是3000</p></blockquote><pre><code class="language-bash">$ git clone git@github.com:Binaryify/NeteaseCloudMusicApi.git$ cd NeteaseCloudMusicApi &amp;&amp; npm install$ npm start</code></pre><blockquote><p>在运行本项目前，确保系统已经全局安装了taro，<a href="https://nervjs.github.io/taro/docs/GETTING-STARTED.html" target="_blank" rel="noopener">安装可详见这里</a>，安装完运行项目后使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">微信开发者工具</a> 导入项目（本项目根目录进行导入），开发前注意事项可查看: <a href="https://nervjs.github.io/taro/docs/before-dev-remind.html" target="_blank" rel="noopener">https://nervjs.github.io/taro/docs/before-dev-remind.html</a></p></blockquote><pre><code class="language-bash"># git clone$ git clone https://github.com/huangzhuangjia/taro-music.git# install$ npm i# or yarn install$ yarn install# development$ npm run dev:weapp# production$ npm run build:weapp</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 小程序，React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化总结</title>
      <link href="/2018/03/14/performance-optimization/"/>
      <url>/2018/03/14/performance-optimization/</url>
      
        <content type="html"><![CDATA[<h1>优化的原则和方向</h1><p>前端性能优化的原则其实就是更好的用户体验，具体实现的目标大体有两个：</p><blockquote><ol><li>合理使用内存或缓存，减少请求；</li><li>减少CPU或者GPU的计算，达到更快的展现。</li></ol></blockquote><p>前端在性能优化的方向大体有两个：</p><blockquote><ol><li>减少页面体积，提升网络加载</li><li>优化页面渲染</li></ol></blockquote><a id="more"></a><h1>详情</h1><h2 id="减少页面体积-提升网络加载"><a class="header-anchor" href="#减少页面体积-提升网络加载"></a>减少页面体积，提升网络加载</h2><p>1、静态资源的压缩合并（JS 代码压缩合并、CSS 代码压缩合并、雪碧图）</p><blockquote><ol><li>压缩是为了减小文件体积，减轻网络负载，达到更快的下载；</li><li>合并和雪碧图都是为了减少文件的请求次数，但不是合并的就一个比没有合并时加载快，要看合并之后的体积，若文件合并后太大了也不太利于性能优化，所以在实际的项目中要做好权衡。</li></ol></blockquote><p>2、静态资源缓存（资源名称加 MD5 戳）</p><blockquote><p>可以通过链接名称控制缓存：通过前端构建工具为打包的文件添加md5后缀，这样当打包上线时请求的链接发生改变，这样可以防止由于缓导致静态资源更新失效；</p></blockquote><p>3、 使用 CDN 让资源加载更快</p><h2 id="优化页面渲染"><a class="header-anchor" href="#优化页面渲染"></a>优化页面渲染</h2><p>1、CSS 放前面，JS 放后面</p><blockquote><ol><li>浏览器在渲染解析过程中，若遇到<code>&lt;link href=&quot;...&quot;&gt;</code>和<code>&lt;script src=&quot;...&quot;&gt;</code>这种外链加载 CSS 和 JS 的标签，浏览器会异步下载并解析执行。CSS放在头部是为了让浏览器尽早解析执行Css文件，渲染出页面的样式，若放在底部会出现渲染卡顿的情况，影响性能和体验。</li><li>而当渲染过程中遇到script标签时就会执行JS代码，从阻塞页面渲染，因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。所以要将JS放在底部，等到页面渲染完成之后再去解析执行js，保证用户体验性。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。</li><li>另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。</li></ol></blockquote><p>2、懒加载（图片懒加载、下拉加载更多）</p><blockquote><p>先将src赋值成一个通用的预览图，下拉时候再动态赋值成正式的图片。如下，preview.png是预览图片，比较小，加载很快，而且很多图片都共用这个preview.png，加载一次即可。待页面下拉，图片显示出来时，再去替换src为data-src的值。（data-开头的属性浏览器渲染的时候会忽略掉，提高渲染性能）</p></blockquote><pre><code class="language-js">    &lt;img src=&quot;preview.png&quot; data-src=&quot;realImg.png&quot;/&gt;</code></pre><p>3、减少DOM 查询，对 DOM 查询做缓存</p><pre><code class="language-js">    // 只查询一个 DOM ，缓存在 pList 中了    var pList = document.getElementsByTagName('p')      for (var i = 0; i &lt; pList.length; i++) {    }    // 每次循环，都会查询 DOM ，耗费性能    for (var i = 0; i &lt; document.getElementsByTagName('p').length; i++) {    }</code></pre><p>4、减少DOM 操作，多个操作尽量合并在一起执行（DocumentFragment）</p><blockquote><p>DOM 操作是非常耗费性能的，因此插入多个标签时，先插入 Fragment 然后再统一插入 DOM。因为Fragment文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流。</p></blockquote><pre><code class="language-js">    var listNode = document.getElementById('list')    // 要插入 10 个 li 标签    var frag = document.createDocumentFragment();    var i, li;    for(i = 0; i &lt; 10; i++) {        li = document.createElement(&quot;li&quot;);        li.innerHTML = &quot;List item &quot; + i;        frag.appendChild(li);  //先放在 frag 中，最后一次性插入到 DOM 结构中。    }    listNode.appendChild(frag);</code></pre><p>5、事件节流</p><blockquote><p>在开发过程中会遇到页面一些频繁触发的事件，比如mouseover、scroll、resize等事件。一秒可以执行很多次，这样会造成严重的页面性能问题，导致页面c出现卡顿甚至浏览器崩溃。因此我们需要对事件进行节流，简单的说就是控制其执行的次数。这里就涉及到了常用到的js的节流和防抖功能实现。<br>1、 防抖（debounce）：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</p></blockquote><pre><code class="language-js">    function debounce(fn, delay) {        // 定时器，用来 setTimeout        var timer        // 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 fn 函数        return function () {            // 保存函数调用时的上下文和参数，传递给 fn            var context = this            var args = arguments            // 每次这个返回的函数被调用，就清除定时器，以保证不执行 fn            timer &amp;&amp; clearTimeout(timer)            // 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作），            // 再过 delay 毫秒就执行 fn            timer = setTimeout(function () {                fn.apply(context, args)            }, delay)        }    }</code></pre><blockquote><p>2、节流（throttle）：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</p></blockquote><pre><code class="language-js">    function throttle(fn, threshhold) {        // 记录上次执行的时间        var last        // 定时器        var timer        // 默认间隔为 250ms        threshhold || (threshhold = 250)        // 返回的函数，每过 threshhold 毫秒就执行一次 fn 函数        return function () {            // 保存函数调用时的上下文和参数，传递给 fn            var context = this            var args = arguments            var now = +new Date()            // 如果距离上次执行 fn 函数的时间小于 threshhold，那么就放弃            // 执行 fn，并重新计时            if (last &amp;&amp; now &lt; last + threshhold) {                timer &amp;&amp; clearTimeout(timer)                // 保证在当前时间区间结束后，再执行一次 fn                timer = setTimeout(function () {                    last = now                    fn.apply(context, args)                }, threshhold)            // 在时间区间的最开始和到达指定间隔的时候执行一次 fn            } else {                last = now                fn.apply(context, args)            }        }    }</code></pre><p>6、尽早执行操作（DOMContentLoaded）</p><pre><code class="language-js">    window.addEventListener('load', function () {        // 页面的全部资源加载完才会执行，包括图片、视频等    })    document.addEventListener('DOMContentLoaded', function () {        // DOM 渲染完即可执行，此时图片、视频还可能没有加载完    })    $(document).ready({function () {        // 同DOMContentLoaded    })</code></pre><p>7、使用 <strong>预渲染</strong> 或者 <strong>SSR后端渲染</strong>，数据直接输出到 HTML 中，减少浏览器使用 JS 模板渲染页面 HTML 的时间 (如Vue SSR)，同时也有利于网站的SEO。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Vue响应式原理</title>
      <link href="/2018/02/07/About-responsive-of-Vue/"/>
      <url>/2018/02/07/About-responsive-of-Vue/</url>
      
        <content type="html"><![CDATA[<h1>初步</h1><p>最近一段时间在阅读Vue源码，从它的核心原理入手，开始了源码的学习，而其核心原理就是其数据的响应式，讲到Vue的响应式原理，我们可以从它的兼容性说起，Vue不支持IE8以下版本的浏览器，因为Vue是基于 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty</a> 来实现数据响应的，而 Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因；Vue通过Object.defineProperty的 <strong>getter/setter</strong> 对收集的依赖项进行监听,在属性被访问和修改时通知变化,进而更新视图数据；</p><p>受现代JavaScript 的限制 (以及废弃 <strong>Object.observe</strong>)，Vue不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 <strong>getter/setter</strong> 转化过程，所以属性必须在 <strong>data</strong> 对象上存在才能让Vue转换它，这样才能让它是响应的。</p><a id="more"></a><p><img src="https://cn.vuejs.org/images/data.png" alt="vue响应式"></p><p>我们这里是根据Vue2.3源码进行分析,Vue数据响应式变化主要涉及 <strong>Observer</strong>, <strong>Watcher</strong> , <strong>Dep</strong> 这三个主要的类；因此要弄清Vue响应式变化需要明白这个三个类之间是如何运作联系的；以及它们的原理，负责的逻辑操作。那么我们从一个简单的Vue实例的代码来分析Vue的响应式原理</p><pre><code class="language-javascript">var vue = new Vue({    el: &quot;#app&quot;,    data: {        name: 'Junga'    },    created () {        this.helloWorld()    },    methods: {        helloWorld: function() {            console.log('my name is' + this.name)        }    }    ...})</code></pre><h1>Vue初始化实例</h1><p>根据Vue的<a href="https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">生命周期</a>我们知道，Vue首先会进行init初始化操作；源码在<a href="https://github.com/huangzhuangjia/Vue-learn/blob/master/core/instance/init.js" target="_blank" rel="noopener">src/core/instance/init.js</a>中</p><pre><code class="language-js">/*初始化生命周期*/initLifecycle(vm)/*初始化事件*/initEvents(vm)Object.defineProperty /*初始化render*/initRender(vm)/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/callHook(vm, 'beforeCreate')initInjections(vm) // resolve injections before data/props/*初始化props、methods、data、computed与watch*/initState(vm)initProvide(vm) // resolve provide after data/props/*调用created钩子函数并且触发created钩子事件*/callHook(vm, 'created')</code></pre><p>以上代码可以看到 <strong>initState(vm)</strong> 是用来初始化props,methods,data,computed和watch;</p><p><a href="https://github.com/huangzhuangjia/Vue-learn/blob/master/core/instance/state.js" target="_blank" rel="noopener">src/core/instance/state.js</a></p><pre><code class="language-js">/*初始化props、methods、data、computed与watch*/export function initState (vm: Component) {  vm._watchers = []  const opts = vm.$options  /*初始化props*/  if (opts.props) initProps(vm, opts.props)  /*初始化方法*/  if (opts.methods) initMethods(vm, opts.methods)  /*初始化data*/  if (opts.data) {    initData(vm)  } else {    /*该组件没有data的时候绑定一个空对象*/    observe(vm._data = {}, true /* asRootData */)  }  /*初始化computed*/  if (opts.computed) initComputed(vm, opts.computed)  /*初始化watchers*/  if (opts.watch) initWatch(vm, opts.watch)}.../*初始化data*/function initData (vm: Component) {  /*得到data数据*/  let data = vm.$options.data  data = vm._data = typeof data === 'function'    ? getData(data, vm)    : data || {}defi  ...  //遍历data中的数据  while (i--) {    /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/    if (props &amp;&amp; hasOwn(props, keys[i])) {      process.env.NODE_ENV !== 'production' &amp;&amp; warn(        `The data property &quot;${keys[i]}&quot; is already declared as a prop. ` +        `Use prop default value instead.`,        vm      )    } else if (!isReserved(keys[i])) {      /*判断是否是保留字段*/      /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/      proxy(vm, `_data`, keys[i])    }  }  // observe data  /*这里通过observe实例化Observe对象，开始对数据进行绑定，asRootData用来根数据，用来计算实例化根数据的个数，下面会进行递归observe进行对深层对象的绑定。则asRootData为非true*/  observe(data, true /* asRootData */)}</code></pre><h2 id="1-initdata"><a class="header-anchor" href="#1-initdata"></a>1、initData</h2><p>现在我们重点分析下<strong>initData</strong>，这里主要做了两件事，一是将_data上面的数据代理到vm上，二是通过执行 *<em>observe(data, true /</em> asRootData */)**将所有data变成可观察的，即对data定义的每个属性进行getter/setter操作，这里就是Vue实现响应式的基础；<strong>observe</strong>的实现如下 <a href="https://github.com/huangzhuangjia/Vue-learn/blob/master/core/observer/index.js" target="_blank" rel="noopener">src/core/observer/index.js</a></p><pre><code class="language-js"> /*尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。*/export function observe (value: any, asRootData: ?boolean): Observer | void {  if (!isObject(value)) {    return  }  let ob: Observer | void  /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例，这里可以看Observer实例化的代码def(value, '__ob__', this)*/  if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) {    ob = value.__ob__  } else if (    /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。而且该对象在shouldConvert的时候才会进行Observer。这是一个标识位，避免重复对value进行Observer    */    observerState.shouldConvert &amp;&amp;    !isServerRendering() &amp;&amp;    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;    Object.isExtensible(value) &amp;&amp;    !value._isVue  ) {    ob = new Observer(value)  }  if (asRootData &amp;&amp; ob) {     /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/    ob.vmCount++  }  return ob}</code></pre><p>这里 <strong>new Observer(value)</strong> 就是实现响应式的核心方法之一了，通过它将data转变可以成观察的，而这里正是我们开头说的，用了 <strong>Object.defineProperty</strong> 实现了data的 <strong>getter/setter</strong> 操作，通过 <strong>Watcher</strong> 来观察数据的变化，进而更新到视图中。</p><h2 id="2-observer"><a class="header-anchor" href="#2-observer"></a>2、Observer</h2><p>Observer类是将每个目标对象（即data）的键值转换成getter/setter形式，用于进行依赖收集以及调度更新。</p><p><a href="https://github.com/huangzhuangjia/Vue-learn/blob/master/core/observer/index.js" target="_blank" rel="noopener">src/core/observer/index.js</a></p><pre><code class="language-js">export class Observer {  value: any;  dep: Dep;  vmCount: number; // number of vms that has this object as root $data  constructor (value: any) {    this.value = value    this.dep = new Dep()    this.vmCount = 0    /* 将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考/src/core/util/lang.js*/    def(value, '__ob__', this)    if (Array.isArray(value)) {      /*如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。*/      const augment = hasProto        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/      augment(value, arrayMethods, arrayKeys)      /*如果是数组则需要遍历数组的每一个成员进行observe*/      this.observeArray(value)    } else {      /*如果是对象则直接walk进行绑定*/      this.walk(value)    },    walk (obj: Object) {      const keys = Object.keys(obj)      /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/      for (let i = 0; i &lt; keys.length; i++) {        defineReactive(obj, keys[i], obj[keys[i]])      }    }  }</code></pre><ol><li>首先将Observer实例绑定到data的__ob__属性上面去，防止重复绑定；</li><li>若data为数组，先实现对应的<a href="https://cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">变异方法</a>（这里变异方法是指Vue重写了数组的7种原生方法，这里不做赘述，后续再说明），再将数组的每个成员进行observe，使之成响应式数据；</li><li>否则执行walk()方法，遍历data所有的数据，进行getter/setter绑定，这里的核心方法就是 <strong>defineReative(obj, keys[i], obj[keys[i]])</strong></li></ol><pre><code class="language-js">export function defineReactive (  obj: Object,  key: string,  val: any,  customSetter?: Function) {  /*在闭包中定义一个dep对象*/  const dep = new Dep()  const property = Object.getOwnPropertyDescriptor(obj, key)  if (property &amp;&amp; property.configurable === false) {    return  }  /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/  // cater for pre-defined getter/setters  const getter = property &amp;&amp; property.get  const setter = property &amp;&amp; property.set  /*对象的子对象递归进行observe并返回子节点的Observer对象*/  let childOb = observe(val)  Object.defineProperty(obj, key, {    enumerable: true,    configurable: true,    get: function reactiveGetter () {      /*如果原本对象拥有getter方法则执行*/      const value = getter ? getter.call(obj) : val      if (Dep.target) {        /*进行依赖收集*/        dep.depend()        if (childOb) {          /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/          childOb.dep.depend()        }        if (Array.isArray(value)) {          /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/          dependArray(value)        }      }      return value    },    set: function reactiveSetter (newVal) {      /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/      const value = getter ? getter.call(obj) : val      /* eslint-disable no-self-compare */      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {        return      }      /* eslint-enable no-self-compare */      if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) {        customSetter()      }      if (setter) {        /*如果原本对象拥有setter方法则执行setter*/        setter.call(obj, newVal)      } else {        val = newVal      }      /*新的值需要重新进行observe，保证数据响应式*/      childOb = observe(newVal)      /*dep对象通知所有的观察者*/      dep.notify()    }  })}</code></pre><p>其中getter方法：</p><ol><li>先为每个data声明一个 <strong>Dep</strong> 实例对象，被用于getter时执行dep.depend()进行收集相关的依赖;</li><li>根据Dep.target来判断是否收集依赖，还是普通取值。Dep.target是在什么时候，如何收集的后面再说明，先简单了解它的作用，</li></ol><p>那么问题来了，我们为啥要收集相关依赖呢？</p><pre><code class="language-js">new Vue({    template:         `&lt;div&gt;            &lt;span&gt;text1:&lt;/span&gt; {{text1}}            &lt;span&gt;text2:&lt;/span&gt; {{text2}}        &lt;div&gt;`,    data: {        text1: 'text1',        text2: 'text2',        text3: 'text3'    }});</code></pre><p>我们可以从以上代码看出，data中text3并没有被模板实际用到，为了提高代码执行效率，我们没有必要对其进行响应式处理，因此，依赖收集简单点理解就是收集只在实际页面中用到的data数据，然后打上标记，这里就是标记为Dep.target。</p><p>在setter方法中:</p><ol><li>获取新的值并且进行observe，保证数据响应式；</li><li>通过dep对象通知所有观察者去更新数据，从而达到响应式效果。</li></ol><p>在Observer类中，我们可以看到在getter时，dep会收集相关依赖，即收集依赖的watcher，然后在setter操作时候通过dep去通知watcher,此时watcher就执行变化，其实我们可以简单理解：Dep可以看做是书店，Watcher就是书店订阅者，而Observer就是书店的书，订阅者在书店订阅书籍，就可以添加订阅者信息，一旦有新书就会通过书店给订阅者发送消息。</p><h2 id="3-watcher"><a class="header-anchor" href="#3-watcher"></a>3、Watcher</h2><p>Watcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Dep的subs中，数据变动的时候Dep会通知Watcher实例，然后由Watcher实例回调cb进行视图的更新。</p><p><a href="https://github.com/huangzhuangjia/Vue-learn/blob/master/core/observer/watcher.js" target="_blank" rel="noopener">src/core/observer/watcher.js</a></p><pre><code class="language-js">export default class Watcher {  constructor (    vm: Component,    expOrFn: string | Function,    cb: Function,    options?: Object  ) {    this.vm = vm    /*_watchers存放订阅者实例*/    vm._watchers.push(this)    // options    if (options) {      this.deep = !!options.deep      this.user = !!options.user      this.lazy = !!options.lazy      this.sync = !!options.sync    } else {      this.deep = this.user = this.lazy = this.sync = false    }    this.cb = cb    this.id = ++uid // uid for batching    this.active = true    this.dirty = this.lazy // for lazy watchers    this.deps = []    this.newDeps = []    this.depIds = new Set()    this.newDepIds = new Set()    this.expression = process.env.NODE_ENV !== 'production'      ? expOrFn.toString()      : ''    // parse expression for getter    /*把表达式expOrFn解析成getter*/    if (typeof expOrFn === 'function') {      this.getter = expOrFn    } else {      this.getter = parsePath(expOrFn)      if (!this.getter) {        this.getter = function () {}        process.env.NODE_ENV !== 'production' &amp;&amp; warn(          `Failed watching path: &quot;${expOrFn}&quot; ` +          'Watcher only accepts simple dot-delimited paths. ' +          'For full control, use a function instead.',          vm        )      }    }    this.value = this.lazy      ? undefined      : this.get()  }  /**   * Evaluate the getter, and re-collect dependencies.   */   /*获得getter的值并且重新进行依赖收集*/  get () {    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/    pushTarget(this)    let value    const vm = this.vm    /*执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。      在将Dep.target设置为自生观察者实例以后，执行getter操作。      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，      那么在执行getter的时候就会触发a跟c两个数据的getter函数，      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，      将该观察者对象放入闭包中的Dep的subs中去。*/    if (this.user) {      try {        value = this.getter.call(vm, vm)      } catch (e) {        handleError(e, vm, `getter for watcher &quot;${this.expression}&quot;`)      }    } else {      value = this.getter.call(vm, vm)    }    // &quot;touch&quot; every property so they are all tracked as    // dependencies for deep watching    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/    if (this.deep) {      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/      traverse(value)    }    /*将观察者实例从target栈中取出并设置给Dep.target*/    popTarget()    this.cleanupDeps()    return value  }  /**   * Add a dependency to this directive.   */   /*添加一个依赖关系到Deps集合中*/  addDep (dep: Dep) {    const id = dep.id    if (!this.newDepIds.has(id)) {      this.newDepIds.add(id)      this.newDeps.push(dep)      if (!this.depIds.has(id)) {        dep.addSub(this)      }    }  }  /**   * Clean up for dependency collection.   */   /*清理依赖收集*/  cleanupDeps () {    /*移除所有观察者对象*/    ...  }  /**   * Subscriber interface.   * Will be called when a dependency changes.   */   /*      调度者接口，当依赖发生改变的时候进行回调。   */  update () {    /* istanbul ignore else */    if (this.lazy) {      this.dirty = true    } else if (this.sync) {      /*同步则执行run直接渲染视图*/      this.run()    } else {      /*异步推送到观察者队列中，下一个tick时调用。*/      queueWatcher(this)    }  }  /**   * Scheduler job interface.   * Will be called by the scheduler.   */   /*      调度者工作接口，将被调度者回调。    */  run () {    if (this.active) {      /* get操作在获取value本身也会执行getter从而调用update更新视图 */      const value = this.get()      if (        value !== this.value ||        // Deep watchers and watchers on Object/Arrays should fire even        // when the value is the same, because the value may        // have mutated.        /*            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。        */        isObject(value) ||        this.deep      ) {        // set new value        const oldValue = this.value        /*设置新的值*/        this.value = value        /*触发回调*/        if (this.user) {          try {            this.cb.call(this.vm, value, oldValue)          } catch (e) {            handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`)          }        } else {          this.cb.call(this.vm, value, oldValue)        }      }    }  }  /**   * Evaluate the value of the watcher.   * This only gets called for lazy watchers.   */   /*获取观察者的值*/  evaluate () {    this.value = this.get()    this.dirty = false  }  /**   * Depend on all deps collected by this watcher.   */   /*收集该watcher的所有deps依赖*/  depend () {    let i = this.deps.length    while (i--) {      this.deps[i].depend()    }  }  /**   * Remove self from all dependencies' subscriber list.   */   /*将自身从所有依赖收集订阅列表删除*/  teardown () {   ...  }}</code></pre><h2 id="4-dep"><a class="header-anchor" href="#4-dep"></a>4、Dep</h2><p>被Observer的data在触发 <strong>getter</strong> 时，<strong>Dep</strong> 就会收集依赖的 <strong>Watcher</strong> ，其实 <strong>Dep</strong> 就像刚才说的是一个书店，可以接受多个订阅者的订阅，当有新书时即在data变动时，就会通过 <strong>Dep</strong> 给 <strong>Watcher</strong> 发通知进行更新。</p><p><a href="https://github.com/huangzhuangjia/Vue-learn/blob/master/core/observer/dep.js" target="_blank" rel="noopener">src/core/observer/dep.js</a></p><pre><code class="language-js">export default class Dep {  static target: ?Watcher;  id: number;  subs: Array&lt;Watcher&gt;;  constructor () {    this.id = uid++    this.subs = []  }  /*添加一个观察者对象*/  addSub (sub: Watcher) {    this.subs.push(sub)  }  /*移除一个观察者对象*/  removeSub (sub: Watcher) {    remove(this.subs, sub)  }  /*依赖收集，当存在Dep.target的时候添加观察者对象*/  depend () {    if (Dep.target) {      Dep.target.addDep(this)    }  }  /*通知所有订阅者*/  notify () {    // stabilize the subscriber list first    const subs = this.subs.slice()    for (let i = 0, l = subs.length; i &lt; l; i++) {      subs[i].update()    }  }}</code></pre><h1>总结</h1><p>其实在 <strong>Vue</strong> 中初始化渲染时，视图上绑定的数据就会实例化一个 <strong>Watcher</strong>，依赖收集就是是通过属性的 <strong>getter</strong> 函数完成的，文章一开始讲到的 <strong>Observer</strong> 、<strong>Watcher</strong> 、<strong>Dep</strong> 都与依赖收集相关。其中 <strong>Observer</strong> 与 <strong>Dep</strong> 是一对一的关系， <strong>Dep</strong> 与 <strong>Watcher</strong> 是多对多的关系，<strong>Dep</strong> 则是 <strong>Observer</strong> 和 <strong>Watcher</strong> 之间的纽带。依赖收集完成后，当属性变化会执行被 <strong>Observer</strong> 对象的 <strong>dep.notify()</strong> 方法，这个方法会遍历订阅者（Watcher）列表向其发送消息， <strong>Watcher</strong> 会执行 <strong>run</strong> 方法去更新视图，我们再来看一张图总结一下：<br><img src="https://raw.githubusercontent.com/huangzhuangjia/Vue-learn/master/doc/img/vue-reactive.jpg" alt="关系图"></p><ol><li>在 <strong>Vue</strong> 中模板编译过程中的指令或者数据绑定都会实例化一个 <strong>Watcher</strong> 实例，实例化过程中会触发 <strong>get()</strong> 将自身指向 <strong>Dep.target</strong>;</li><li>data在 <strong>Observer</strong> 时执行 <strong>getter</strong> 会触发 <strong>dep.depend()</strong> 进行依赖收集;依赖收集的结果：1、data在 <strong>Observer</strong> 时闭包的dep实例的subs添加观察它的 <strong>Watcher</strong> 实例；2. <strong>Watcher</strong> 的deps中添加观察对象 <strong>Observer</strong> 时的闭包dep；</li><li>当data中被 <strong>Observer</strong> 的某个对象值变化后，触发subs中观察它的watcher执行 <strong>update()</strong> 方法，最后实际上是调用watcher的回调函数cb，进而更新视图。</li></ol><h1>参考</h1><ul><li><a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">Vue源码</a></li><li><a href="https://cn.vuejs.org" target="_blank" rel="noopener">Vue文档</a></li><li><a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener">Vue源码学习</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vue，源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于移动端开发中遇到的坑</title>
      <link href="/2017/07/30/something-about-web-app/"/>
      <url>/2017/07/30/something-about-web-app/</url>
      
        <content type="html"><![CDATA[<p>三月中旬跳完槽之后就好好久没写博客了，跳到某公司之后，怀揣着满腔热水的我又投入了工作中，从面试、办理离职到入职只用了一个星期。这效率也没谁了，入职之后给了一个小项目，用Vue全家桶开发一个简易的个人博客。因为之前自学了解过，于是很快就上手，原本要求用两周的时间用了三天就完成了全部的功能，于是就一周之后就开始安排到项目组进行实际的开发中了，最后被安排到招聘组负责校招的前端开发。一去就搞事情，给我安排了后台移动端的开发，就是为了方便领导手机上使用，基于内部项目都是用了Vue，最后确定用Vue+一个移动端的基于Vue的UI框架Vux进行开发，于是就进入了移动端的踩坑之旅，之前比较少接触移动端开发。<br>项目开发是基于Vue的UI框架Vux，其实就是一套基于We-UI的一套移动端UI框架，但根据实际情况，一些布局还是得自己去重构。于是就愉快的踩起了移动端开发的坑。</p><a id="more"></a><h1>滚动穿透问题</h1><p>滚动穿透是指在移动端当有 fixed 遮罩背景和弹出层时，在屏幕上滑动能够滑动背景下面的内容。网上整理了解决方案，但有些还是存在一定的问题：</p><h2 id="设置overflow为hidden"><a class="header-anchor" href="#设置overflow为hidden"></a>设置overflow为hidden</h2><pre><code class="language-css">.modal-open {    &amp;, body {        overflow: hidden;        height: 100%    }}</code></pre><p>即当弹出层弹出时在html上添加.modal-open,禁用 html 和 body 的滚动条,但实际用上就会发现：</p><ol><li>由于 html 和 body的滚动条都被禁用，弹出层后页面的滚动位置会丢失，需要用 js 来计算原来滚动的位置，在弹出时保持滚动位置；</li><li>杯具(＞﹏＜)的是页面的背景还是能够有滚的动的效果</li></ol><h2 id="js-之-touchmove-preventdefault"><a class="header-anchor" href="#js-之-touchmove-preventdefault"></a>js 之 touchmove + preventDefault</h2><pre><code class="language-js">modal.addEventListener('touchmove', function(e) {  e.preventDefault();}, false);</code></pre><p>即通过阻止移动端touchmove事件，但实际用上会发现弹出层需要滚动时也会被阻止(＞﹏＜)</p><h2 id="最后解决方案：position-fixed"><a class="header-anchor" href="#最后解决方案：position-fixed"></a>最后解决方案：position: fixed</h2><pre><code class="language-css">body.modal-open {    position: fixed;    width: 100%;}</code></pre><p>这种方式同样当弹出层弹出时滚动条会丢失，所以还需要使用js来保存滚动条的位置，在关闭弹出层时将滚动位置还原；</p><pre><code class="language-js">var ModalHelper = (function(bodyCls) {  var scrollTop; // 在闭包中定义一个用来保存滚动位置的变量  return {    afterOpen: function() { //弹出之后记录保存滚动位置，并且给body添加.modal-open      scrollTop = document.scrollingElement.scrollTop;      document.body.classList.add(bodyCls);      document.body.style.top = -scrollTop + 'px';    },    beforeClose: function() { //关闭时将.modal-open移除并还原之前保存滚动位置      document.body.classList.remove(bodyCls);      document.scrollingElement.scrollTop = scrollTop;    }  };})('modal-open');</code></pre><p>本人亲测确实比较完美解决了移动端滚动问题😊</p><h1>移动端输入框被键盘挡住问题</h1><p>由于所开发的页面内嵌在公司的一个APP中，有一个类似聊天窗口的界面，测试的时候发现在部分安卓机中输入框被完全遮挡住，踩这个坑时在网上找了好多资料，好像都没有一套完整的解决办法，先看其中一种解决办法，可以解决绝大数安卓机上面的问题：</p><pre><code class="language-js">if(/Android/.test(navigator.appVersion)) {   window.addEventListener(&quot;resize&quot;, function() {     if(document.activeElement.tagName==&quot;INPUT&quot; || document.activeElement.tagName==&quot;TEXTAREA&quot;) {       document.activeElement.scrollIntoView();     }  })}</code></pre><p>即在安卓机中通过监听当窗口resize时，判断当前获得焦点的元素是否为输入框，再调用该元素的scrollIntoView()，即将该元素展示在当前窗口的可视区域。由于只有scrollIntoView被各浏览器均支持，所以这个方法最为常用。<br>使用这段代码之后，在微信或者其他浏览器测试时有效果，但因为是需要内嵌在自家APP上，使用这段代码一直没有解决输入框被挡住的问题，最后测试才发现，APP内置浏览器在聚焦输入框弹出键盘根本没有触发窗口的resize事件，瞬间心中万马奔腾(＞﹏＜)~~~，后面在借鉴了某阿里的一个网页版的聊天界面，发现它是通过获取输入框焦点将输入框定位到窗口略高于输入框的位置，在失去焦点键盘弹回时再恢复到底部，于是通过这种方式处理，暂时比较暴力的解决了在安卓上该APP上输入框被挡住的问题，这种方法显然是不完美的，比如由于无法监听resize事件，而且使用的键盘高度不固定，所以只能大概的将高度设置保持在屏幕一半偏上一点。保证绝大数情况下输入框在键盘之上显示。</p><h1>IOS滚动不平滑的问题</h1><p>在移动端特别是iOS中，当滚动屏幕时会发现手指一拿开滚动就停止，这种用户体验效果很不好，有种给用户滚动卡顿的感觉。CSS3中的-webkit-overflow-scrolling属性可以完美的解决这个问题，该属性可控制元素在移动设备上是否使用滚动回弹效果:</p><ol><li>auto</li></ol><blockquote><p>使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。</p></blockquote><ol start="2"><li>touch</li></ol><blockquote><p>使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 移动端web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域与闭包的一二事</title>
      <link href="/2017/03/05/scope-and-closure/"/>
      <url>/2017/03/05/scope-and-closure/</url>
      
        <content type="html"><![CDATA[<p>闭包是JavaScript语言的一大特点，可以说再开发的过程中，它无处不在，即使有时候我们都没有发现它的存在。接触JavaScript以来，虽然说是一直有对闭包了解，但是实际应用起来或者分析一些代码的时候却有些吃力。现在回过头总结，才又进一步的揭开了闭包的一层面纱。而在讲闭包之前，我们要先明白JavaScript中又一个重要的知识，那就是JavaScript的内存机制以及作用域，这两个是我们有效理解闭包原理的前提吧。前面我们已经讲了JavaScript的内存机制，那么在这里先理解什么是作用域和作用域链。</p><h1>作用域与作用域链</h1><p>之前我们已经了解了JavaScript内存以及垃圾回收的机制了，在讲作用域之前，其实还有一个知识点，那就是JavaScript的执行环境产生的变量对象。</p><a id="more"></a><h2 id="变量对象"><a class="header-anchor" href="#变量对象"></a>变量对象</h2><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。而每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但是解析器在处理数据时会在后台处理它们。</p><p>JavaScript的运行环境大概有三种：</p><ol><li>全局环境：全局环境是最外围的一个执行环境。在web浏览器中，全局执行环境被认为是window对象，因此所有的全局变量和函数都会作为window对象的属性和方法创建的；</li><li>局部环境：通常是函数内部创建的执行环境。</li><li>eval</li></ol><p>变量对象的创建过程：</p><ol><li>创建arguments对象。检查当前执行环境中的参数，建立该对象下的属性与属性值。</li><li>检查当前执行环境中的函数声明，即function关键字的函数声明，在变量对象中以函数名建立一个属性，其值是指向该函数所在内存地址的引用。若函数名已经存在，则改属性将会被新的引用说覆盖。</li><li>检查当前执行环境中的变量声明，在变量对象以变量名建立一个属性，并初始化为undefined。</li></ol><div align="center">    <img src="https://github.com/huangzhuangjia/BlogImages/blob/master/img/img05.png?raw=true" alt="变量对象"></div><p>我们经常说到的变量提升，函数优先提升就是这样一个过程，在每个执行环境中的变量对象被创建的时候都会经历这几个步骤。<br>而当某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的变量和函数定义也随之销毁，全局执行环境直到应用程序退出比如浏览器关闭时才会销毁。</p><h2 id="作用域"><a class="header-anchor" href="#作用域"></a>作用域</h2><p>了解了变量对象之后，我们在这里给作用域一个定义，作用域就是用来管理JavaScript引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称（这里指的是变量名和函数名）进行变量查找的一套规则。说的简单点就是作用域就是变量与函数的可访问范围，它控制着变量与函数的可见性与生命周期。</p><p>JavaScript代码的整个执行过程分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器执行完成，将代码编译成可执行代码，并确立作用域的规则。执行阶段由引擎完成，主要是执行可执行代码，执行上下文在这个阶段创建。</p><p><img src="https://github.com/huangzhuangjia/BlogImages/blob/master/img/img06.png?raw=true" alt="执行过程"></p><p>我们举一个简单粗暴的🌰解释一下引擎、编译器和作用域是如何协同工作的就明白了：</p><pre><code class="language-js">var a = 10;</code></pre><p>JavaScript执行上面代码的时候会将其看成是两个声明，一个是编译阶段的定义声明，一个是引擎执行阶段的赋值声明，所以我们可以分解成：</p><pre><code class="language-js">var a;a=10;</code></pre><ol><li>编译阶段：“编译器&quot;会询问&quot;作用域”：当前的作用域中是否已经有变量a，如果有，那么&quot;编译器&quot;会忽略这个声明，继续进行编译；如果没有，那么它会要求“作用域”在当前的作用域声明一个新的变量，并命名为a;</li><li>执行阶段：“引擎&quot;处理a = 10时，首先会询问&quot;作用域”：当前的作用域中是否存在一个a的变量，如果存在，那么引擎就会使用这个变量，如果否，那么&quot;引擎&quot;会继续查找该变量。如果&quot;引擎&quot;最终找到了a变量，那么就将10赋值给它，否则&quot;引擎&quot;就会抛出一个异常。</li><li>总结一下变量赋值操作过程，即：首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时，引擎会在作用域中查找该变量，如果能够找到就对它赋值，否则就抛出异常。</li></ol><blockquote><p>编译阶段是在当前的作用域中声明变量，而引擎查找时，是在整个作用域中查找该变量。</p></blockquote><h2 id="作用域链"><a class="header-anchor" href="#作用域链"></a>作用域链</h2><p>上面我们讲了，引擎在查找变量的时候，是在整个作用域中查找的，在当前作用域中找不到它会继续往上一层作用域中查找，直至到顶层作用域即全局作用域。而这一个过程中就产生了我们所说的作用域链，作用域链是在执行上下文创建的时候产生的。</p><p><img src="https://github.com/huangzhuangjia/BlogImages/blob/master/img/img07.png?raw=true" alt="执行过程"></p><p>我们说作用域是JavaScript编译执行的一套规则，那么作用域链就是这个规则的一种具体体现。</p><blockquote><p>作用域链是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终是当前执行的代码所在环境的变量对象。而前面我们已经讲了变量对象的创建过程。作用域链的下一个变量对象来自包含环境即外部环境，这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p></blockquote><h1>闭包</h1><h2 id="定义"><a class="header-anchor" href="#定义"></a>定义</h2><p>理解了作用域与作用域链之后，我们再来看看闭包的一些定义：</p><p>MDN 对闭包的定义：</p><blockquote><p>闭包是指那些能够访问独立（自由）变量的函数（变量在本地使用，但定义在一个封闭的作用域中）。换句话说，这些函数可以「记忆」它被创建时候的环境。</p></blockquote><p>《JavaScript 权威指南(第6版)》对闭包的定义：</p><blockquote><p>函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为闭包。</p></blockquote><p>《JavaScript 高级程序设计(第3版)》对闭包的定义：</p><blockquote><p>闭包是指有权访问另一个函数作用域中的变量的函数。</p></blockquote><p>最后是阮一峰老师对闭包的解释：</p><blockquote><p>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成定义在一个函数内部的函数。</p></blockquote><p>从以上定义我们可以总结，我们可以简单理解就是一个函数被一个外部函数所包含，根据上面我们讲到的作用域链只是我们可以知道，当前被包含的函数内部（即当前的执行环境）是有权访问它外部函数（外部的执行环境）的变量对象的，那么这个函数就是我们所说的闭包了。原来对闭包的理解就是这么的通畅，哈哈😆。</p><h2 id="闭包的用途"><a class="header-anchor" href="#闭包的用途"></a>闭包的用途</h2><p>我们都知道，当函数执行完毕的时候，局部的活动对象就会退出执行栈，随后就会被销毁，但是闭包则不是酱紫的。废话不多说，我们再来看一个🌰（图画的有点丑，将就着看吧哈哈）</p><pre><code class="language-js">function fun(){    var name = &quot;Junga&quot;    function fun1(){        var greet = 'Hello '+ name;        console.log(greet);    }    return fun1;}var result = fun();result();</code></pre><div align="center">    <img src="https://github.com/huangzhuangjia/BlogImages/blob/master/img/img08.png?raw=true" alt="执行过程"></div><p>上图展示的是调用函数fun()的过程中产生的作用域链之间的关系。作用域链本质上就是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。上面代码很明显，fun1()就是一个闭包，因为它的作用域链包含了外部函数fun()的活动对象，那为什么闭包在运行完之后不会被销毁呢？下面解释一下：</p><p>在函数fun()中，返回了内部函数fun1()，它的作用域链被初始化为包含fun()函数的活动对象和全局变量对象。因此，fun1()就可以访问fun()中定义的所有变量。接下来最重要的一点就是，fun()函数在执行完毕之后其活动对象也不会被销毁，因为闭包fun1()的作用域链仍然在引用这个活动对象。换句话说，当fun()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中，直到闭包fun1()被销毁后，fun()的活动对象才会被销毁。例如当上面的result被赋值为null时，此时闭包fun1()就被解除了引用，随后被垃圾收集器回收，最后释放其内存。</p><blockquote><p>因此，可以总结出闭包有两大用途：1、可以读取函数内部的变量；2、可以让函数内部的变量始终保存在内存中。<br>注意：由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存，过度使用闭包可能会导致内存泄漏。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flexbox学习小记</title>
      <link href="/2017/02/23/flexbox/"/>
      <url>/2017/02/23/flexbox/</url>
      
        <content type="html"><![CDATA[<p>因为现在的公司要求布局的兼容性要兼容到至少IE7，所以对于flexbox这种布局也没有了解太多，之前有听说过flex布局，听起来是一种比较高大上，可以自适应不同尺寸屏幕的布局方式，但是没有正式的去学习了解。flexbox是CSS3算是比较新的一个特性，最近刚好有时间也有兴趣就了解了，觉得还是要做一下总结，不然很快又忘了😰。</p><p>flexbox布局意为弹性布局，是css3的弹性盒子模式，用它可以告别float布局，也可以简单实现垂直居中，并且具有响应式，就是可以自动调整，计算元素在容器空间中的大小，可以说：完美~~~（此处应有标志性动作)</p><blockquote><p>Flex布局背后的主要思想是给容器控制项目（Flex项目）的宽度、高度的能力，使用Flex项目可以自动填满容器的可用空间（主要是适应所有类型的显示设备和屏幕大小）。Flex容器使用Flex项目可以自动放大与收缩，用来填补可用的空闲空间。</p></blockquote><a id="more"></a><p>先看下flexbox布局对各大浏览器的支持情况，基本也就告别低版本的浏览器了：</p><div align="center">  <img src="https://github.com/huangzhuangjia/BlogImages/blob/master/img/img04.jpeg?raw=true" alt="兼容性示意图"></div><p>下面我们来简单了解一下flex布局的基本概念：</p><h1>flex项目排列方式：</h1><div align="center"> <img src="http://www.w3cplus.com/sites/default/files/blogs/2015/1504/flexbox.png" alt="示意图"></div><ul><li>main axis:Flex容器的主轴主要用来配置Flex项目。注意，它不一定是水平，这主要取决于flex-direction属性。</li><li>main-start | main-end:Flex项目的配置从容器的主轴起点边开始，往主轴终点边结束。</li><li>main size:Flex项目的在主轴方向的宽度或高度就是项目的主轴长度，Flex项目的主轴长度属性是width或height属性，由哪一个对着主轴方向决定。</li><li>cross axis:与主轴垂直的轴称作侧轴，是侧轴方向的延伸。</li><li>cross-start | cross-end:伸缩行的配置从容器的侧轴起点边开始，往侧轴终点边结束。</li><li>cross size:Flex项目的在侧轴方向的宽度或高度就是项目的侧轴长度，Flex项目的侧轴长度属性是width或height属性，由哪一个对着侧轴方向决定。</li></ul><h1>flex布局拥有的属性：</h1><h2 id="父容器的属性"><a class="header-anchor" href="#父容器的属性"></a>父容器的属性</h2><ul><li>display:flex | inline-flex。 表明这个容器是flex布局。flex是块伸缩容器，inline-flex是内联伸缩容器。</li><li>flex-direction: row | row-reverse | column | column-reverse; 表明容器里面的子元素的排列方向。</li><li>flex-wrap: nowrap | wrap | wrap-reverse; 如果子元素溢出父容器的时候是否进行换行。</li><li>justify-content: flex-start | flex-end | center | space-between | space-around; 这一个容器子元素横向排版在容器的哪个位置</li><li>align-items: flex-start | flex-end | center | baseline | stretch; 这个容器子元素纵向排版在容器的哪个位置</li><li>align-content: flex-start | flex-end | center | space-between | space-around | stretch; 当容器内有多行项目的时候，项目的布局</li></ul><h2 id="子元素的属性"><a class="header-anchor" href="#子元素的属性"></a>子元素的属性</h2><ul><li>order: ; 子元素的排序</li><li>flex-grow: ; 分配剩余空间的比例</li><li>flex-shrink: ; 分配溢出空间的比例</li><li>flex-basis: | auto;</li><li>flex: none | [ &lt;‘flex-grow’&gt; &lt;‘flex-shrink’&gt;? || &lt;‘flex-basis’&gt; ] 在容器中占比</li><li>align-self: auto | flex-start | flex-end | center | baseline | stretch; 特定某个子元素的排布情况</li></ul><h1>属性详解</h1><h2 id="flex容器属性："><a class="header-anchor" href="#flex容器属性："></a>Flex容器属性：</h2><h3 id="display属性"><a class="header-anchor" href="#display属性"></a>display属性</h3><p>display定义了一个Flex容器，为其内容建立新的伸缩格式化上下文。其中flex是块伸缩容器，inline-flex是内联伸缩容器。</p><pre><code class="language-css">  .container{      display: flex;/* or inline-flex*/  }</code></pre><blockquote><p>如果元素display的值指定为inline-flex，而且元素是一个浮动元素或绝对定位元素，则display的计算值是flex。</p></blockquote><h3 id="flex-direction属性"><a class="header-anchor" href="#flex-direction属性"></a>flex-direction属性</h3><p>flex-direction定义了flex容器里面的flex项目的排列方向，水平排列和竖直排列</p><pre><code class="language-css">  .container {     flex-direction: row | row-reverse | column | column-reverse;   }</code></pre><ul><li>row(默认值): 主轴为水平方向，从左向右排列</li><li>row-reverse: 主轴为水平方向，从右向左排列</li><li>column: 主轴为垂直方向，从上到下排列</li><li>column-reverse: 主轴为垂直方向，从下向上排列</li></ul><h3 id="flex-wrap属性"><a class="header-anchor" href="#flex-wrap属性"></a>flex-wrap属性</h3><p>flex-wrap定义了当一行或者一列排不上，flex项目是否换行，默认是不换行。</p><pre><code class="language-css">  .container {    flex-wrap: nowrap | wrap | wrap-reverse;  }</code></pre><ul><li>nowrap(默认值): 单行显示不换行</li></ul><p><img src="https://github.com/huangzhuangjia/BlogImages/blob/master/img/img01.jpeg?raw=true" alt="示意图"></p><ul><li>wrap: 多行显示换行，第一行在上方</li></ul><p><img src="https://github.com/huangzhuangjia/BlogImages/blob/master/img/img02.jpeg?raw=true" alt="示意图"></p><ul><li>wrap-reverse: 多行显示换行，第一行在下方</li></ul><p><img src="https://github.com/huangzhuangjia/BlogImages/blob/master/img/img03.jpeg?raw=true" alt="示意图"></p><h3 id="flex-flow属性"><a class="header-anchor" href="#flex-flow属性"></a>flex-flow属性</h3><p>flex-flow是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。道理就跟border: 1px solid red类似，多个值写在同一行。</p><h3 id="justify-content属性"><a class="header-anchor" href="#justify-content属性"></a>justify-content属性</h3><p>justify-content定义了flex项目在flex容器主轴中的对齐方式。</p><pre><code class="language-css"> container{   justify-content: {flex-start | flex-end | center | space-between | space-around; }</code></pre><div align="center">  <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="示意图"></div><ul><li>flex-start（默认值）：flex项目在主轴方向上进行左对齐</li><li>flex-end：flex项目在主轴方向上进行右对齐</li><li>center： flex项目在主轴方向上进行居中</li><li>space-between：flex项目两端对齐，项目之间的间隔都相等。</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><h3 id="align-items属性"><a class="header-anchor" href="#align-items属性"></a>align-items属性</h3><p>align-items定义了flex项目在flex容器竖轴上的对齐方式。类似justify-content属性，只不过是方向不同。</p><pre><code class="language-css"> container{   align-items: {flex-start | flex-end | center | baseline | stretch; }</code></pre><div align="center">  <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="示意图"></div><ul><li>flex-start（默认值）：flex项目在flex容器竖轴方向起点对齐。</li><li>flex-end：flex项目在flex容器竖轴方向终点对齐。</li><li>center：flex项目在flex容器竖轴方向中点对齐。</li><li>baseline: 项目的第一行文字的基线对齐。</li><li>stretch：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><h3 id="align-content属性"><a class="header-anchor" href="#align-content属性"></a>align-content属性</h3><p>align-content属性定义了多根轴线的对齐方式。当伸缩容器的侧轴还有多余空间时，align-content属性可以用来调准伸缩行在伸缩容器里的对齐方式，这与调准伸缩项目在主轴上对齐方式的justify-content属性类似。</p><pre><code class="language-css">  container{    align-items: {flex-start | flex-end | center | baseline | stretch;  }</code></pre><div align="center">  <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="示意图"></div><ul><li>flex-start：与竖轴方向的起点对齐。</li><li>flex-end：与竖轴方向的终点对齐。</li><li>center：与竖轴方向的中点对齐。</li><li>space-between：与竖轴的两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个竖轴方向。</li></ul><h2 id="flex项目属性："><a class="header-anchor" href="#flex项目属性："></a>Flex项目属性：</h2><h3 id="order属性"><a class="header-anchor" href="#order属性"></a>order属性</h3><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><pre><code class="language-css"> .item {   order: &lt;integer&gt;; }</code></pre><blockquote><p>根据order重新排序伸缩项目。有最小（负值最大）order的伸缩项目排在第一个。若有多个项目有相同的order值，这些项目照文件顺序排。这个步骤影响了伸缩项目生盒树成的盒子的顺序，也影响了后面的演算法如何处理各项目。</p></blockquote><h3 id="flex-grow属性"><a class="header-anchor" href="#flex-grow属性"></a>flex-grow属性</h3><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。flex-grow取负值将失效。</p><pre><code class="language-css"> .item {   flex-grow: &lt;number&gt;; /* default 0 */ }</code></pre> <div align="center">  <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt="示意图"> </div><p>如上图所示，若所有flex项目的flex-grow属性都为1，则flex容器中的flex项目尺寸都相等，若其中一个为2其他为1，则为其他flex项目的两倍。</p><h3 id="flex-shrink属性"><a class="header-anchor" href="#flex-shrink属性"></a>flex-shrink属性</h3><p>flex-shrink属性则与flex-grow属性相反，定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。与flex-grow一样，flex-shrink取负值将失效。</p><pre><code class="language-css">  .item {    flex-shrink: &lt;number&gt;; /* default 1 */  }</code></pre><h3 id="flex-basis属性"><a class="header-anchor" href="#flex-basis属性"></a>flex-basis属性</h3><p>flex-basis属性定义了Flex项目在分配Flex容器剩余空间之前的一个默认尺寸，通俗一点是说在flex-grow和flex-shrink属性调整它的大小以适应Flex容器之前，可以指定Flex项目的初始大小。它的默认值为auto，即项目的本来大小。flex-basis可以取任何用于width属性的任何值，比如 % || em || rem || px等。</p><blockquote><p>注意：如果flex-basis属性的值是0时，也需要使用单位。即flex-basis: 0px不能写成flex-basis:0。</p></blockquote><pre><code class="language-css"> .item {   flex-basis: &lt;length&gt; | auto; /* default auto */   }</code></pre><h3 id="flex属性"><a class="header-anchor" href="#flex属性"></a>flex属性</h3><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。</p><blockquote><p>注意：flex-grow第一，然后是flex-shrink，最后是flex-basis。缩写成GSB。</p></blockquote><pre><code class="language-css"> .item {    flex: 0 1 auto;/*flex-grow: 0; flex-shrink: 1; flex-basis: auto;*/ }</code></pre><p>flex常见值:</p><ol><li><p>flex: 0 auto,flex: initial与flex: 0 1 auto相同。根据width／height属性决定元素的尺寸。（如果项目的主轴长度属性的计算值为auto，则会根据其内容来决定元素尺寸。）当剩余空间为正值时，伸缩项目无法伸缩，但当空间不足时，伸缩项目可收缩至其最小值。</p></li><li><p>flex: auto与flex: 1 1 auto相同。根据width／height属性决定元素的尺寸，但是完全可以伸缩，会吸收主轴上剩下的空间。</p></li><li><p>flex: none与flex: 0 0 auto相同。根据width／height属性决定元素的尺寸，但是完全不可伸缩，基本上就是一个固定宽度的元素，初始宽度是基于flex项目内容大小。注意：即使在空间不够而溢出的情况下，伸缩项目也不能收缩。</p></li><li><p>flex: <positive-number>与flex: 1 0px相同。该值使元素可伸缩，并将伸缩基准值设置为零，导致该项目会根据设置的比率占用伸缩容器的剩余空间。如果一个伸缩容器里的所有项目都使用此模式，则它们的尺寸会正比于指定的伸缩比率。</positive-number></p></li></ol><p>默认状态下，伸缩项目不会收缩至比其最小内容尺寸（最长的英文词或是固定尺寸元素的长度）更小。网页作者可以靠设置min-width或min-height属性来改变这个默认状态.</p><h3 id="align-self属性"><a class="header-anchor" href="#align-self属性"></a>align-self属性</h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><pre><code class="language-css">  .item {     align-self: auto | flex-start | flex-end | center | baseline | stretch;   }</code></pre><div align="center">  <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="示意图"></div><ul><li>flex-start:伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴起始的边。</li><li>flex-end:伸缩项目在侧轴终点边的外边距靠住该行在侧轴终点的边 。</li><li>center:伸缩项目的外边距盒在该行的侧轴上居中放置。（如果伸缩行的尺寸小于伸缩项目，则伸缩项目会向两个方向溢出相同的量）。</li><li>baseline:如果伸缩项目的行内轴与侧轴为同一条，则该值和flex-start等效。其它情况下，该值将参与基线对齐。所有参与该对齐方式的伸缩项目将按下列方式排列：首先将这些伸缩项目的基线进行对齐，随后其中基线至侧轴起点边的外边距距离最长的那个项目将紧靠住该行在侧轴起点的边。</li><li>stretch:如果侧轴长度属性的值为auto，则此值会使项目的外边距盒的尺寸在遵照min/max-width/height属性的限制下尽可能接近所在行的尺寸。</li></ul><blockquote><p>博客中有些地方是参考阮老师的文章，再自己作总结的，具体可以参考阮老师的<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">《Flex布局教程》</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的内存问题</title>
      <link href="/2017/02/21/javascript-memory/"/>
      <url>/2017/02/21/javascript-memory/</url>
      
        <content type="html"><![CDATA[<p>一直以来，对于Js的内存空间这部分的知识概念有些模糊，最近在回顾一些知识点的时候，特地的对js的内存这部分知识加深了一下理解，比如基本类型数据和引用类型数据在js内存中是怎么回事？什么是按值传递和按引用传递？以及对作用域和闭包的理解等等。</p><h1>JavaScript的内存是怎样的？</h1><p>JavaScript中有两种不同数据类型的值，一种是原始值，另外一种是引用类型值，原始值就是常说的基本数据类型值，包括String、Number、Boolean、Undefined和Null这五大基本数据类型，引用值指的是那些可能由多个指构成的对象，包括Object,Function,Array等类型的值。</p><a id="more"></a><blockquote><p>JavaScript中的内存也分为栈内存和堆内存。一般来说，栈内存中存放的是存储对象的地址，而堆内存中存放的是存储对象的具体内容。对于原始类型的值而言，其地址和具体内容都存在与栈内存中；而基于引用类型的值，其地址存在栈内存，其具体内容存在堆内存中。堆内存与栈内存是有区别的，栈内存运行效率比堆内存高，空间相对堆内存来说较小，反之则是堆内存的特点。所以将构造简单的原始类型值放在栈内存中，将构造复杂的引用类型值放在堆中而不影响栈的效率。</p></blockquote><p>我们看下下面Js的内存示意图：</p><div align="center">  <img src="http://upload-images.jianshu.io/upload_images/599584-cce8e155e19593fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存示意图"></div><pre><code class="language-js">    var a = 20;    var b = 'abc';    var c = true;    var d = { m: 20 }</code></pre><p>可以看出变量a,b,c属于原始数据类型的变量，它们的值都存放在栈内存中，而d是一个对象即属于引用值，栈内存中存放的是它的内存地址，指向堆内存里面具体的一个值。</p><p>接着我们来看下面的一段代码：</p><pre><code class="language-js">    var a = {n:1};    var b = a;    a.x = a = {n:2};    console.log(a.x);// --&gt; undefined    console.log(b.x);// --&gt; [object Object]</code></pre><p>一开始看这道题，然后看答案，一脸懵逼啊有木有？？？为啥结果输出的是undefined和[object Object]？？？</p><p>了解了Js的变量在内存的存储形式之后，我们一起来解释一下：<br>1、a是一个引用类型的变量，一开始它在栈内存中的地址是指向堆内存的具体内容{n:1}，接着赋值给b，所以b和a一样，此时都指向对象{n:1}；</p><pre><code class="language-js">  var a = {n:1} ;  var b = {n:1} ;</code></pre><p>2、接下来a.x = a = {n:2},我们都知道js的赋值运算是从右往左的，但“.”是优先级最高的运算符，所以这段代码先执行了a.x,所以此时对象{n:1}新增加了一个x的属性，并且值是undefined，所以运行到这里a和b都指向了对象{n:1,x:undefined}；</p><pre><code class="language-js">  var a = {n:1，x:undefined} ;  var b = {n:1，x:undefined} ;</code></pre><p>3、接着，依循“从右往左”的赋值运算顺序先执行 a={n:2} ，这时候，a指向的对象发生了改变，变成了新对象{n:2};而a.x = a则是对象{n:1，x:undefined}中的属性x指向了对象{n:2}，所以此时指向的对象变成了{n:1,x:{n:2}}。</p><pre><code class="language-js">  var a = {n:2} ;  var b = {n:1，x:{n:2}} ;</code></pre><p>综上所述，我们可以看到最后的运行结果，显然a.x是undefined，b.x是对象{n:2},用对象的字符串形式[object Object]表示。</p><h2 id="js的内存空间管理"><a class="header-anchor" href="#js的内存空间管理"></a>Js的内存空间管理</h2><p>JavaScript的内存分配和回收是自动完成的，满足一定条件，就会被垃圾回收器自动回收，下面我们简单的了解下js的内存管理机制。</p><h3 id="javascript的内存生命周期"><a class="header-anchor" href="#javascript的内存生命周期"></a>JavaScript的内存生命周期:</h3><ol><li>分配你所需要的内存</li><li>使用分配到的内存（读、写）</li><li>不需要时将其释放、归还</li></ol><pre><code class="language-js">  var num = 10;  // 在内存中给数值变量分配空间  alert(num);  // 使用内存  num = null; // 使用完毕之后，释放内存空间  var obj = {v:1}; // 内存中存在{v:1}对象，及obj这个引用地址  obj = {value:2}; // 垃圾回收机制自动清理{v:1}，并为新的有用到的{value:2}分配空间</code></pre><h3 id="垃圾回收算法"><a class="header-anchor" href="#垃圾回收算法"></a>垃圾回收算法</h3><p>js垃圾回收有两种常见的算法：引用计数和标记清除。</p><h4 id="引用计数"><a class="header-anchor" href="#引用计数"></a>引用计数</h4><p>引用计数就是跟踪对象被引用的次数，当一个对象的引用计数为0即没有其他对象引用它时，说明该对象已经无需访问了，因此就会回收其所占的内存，这样，当垃圾回收器下次运行就会释放引用数为0的对象所占用的内存。</p><blockquote><p>但引用计数存在一个弊端就是循环引用问题（IE6和IE7就是采用此算法）。循环引用就是指对象A中包含一个指向对象B的引用，而对象B中也包含一个指向对象的引用。</p></blockquote><pre><code class="language-js"> function problem() {    var A = {};    var B = {};    A.a = B;    B.a = A;}</code></pre><p>上面例子可以看出对象A和B存在循环音引用的问题，即两个的引用次数均为2，它们在运行之后依然存在，并且引用次数永远不为0，如果这个函数被多次调用，就有可能引起内存泄漏问题。为了解决循环引用的问题，还有一种方法就是可以实现垃圾回收，那就是标记清除法。</p><h4 id="标记清除"><a class="header-anchor" href="#标记清除"></a>标记清除</h4><p>标记清除法是现代浏览器常用的一种垃圾收集方式，当变量进入环境（即在一个函数中声明一个变量）时，就将此变量标记为“进入环境”，进入环境的变量是不能被释放，因为只有执行流进入相应的环境，就可能会引用它们。而当变量离开环境时，就标记为“离开环境”。</p><p>垃圾收集器在运行时会给储存在内存中的所有变量加上标记，然后会去掉环境中的变量以及被环境中的变量引用的变量的标记，当执行完毕那些没有存在引用无法访问的变量就被加上标记，最后垃圾收集器完成清除工作，释放掉那些打上标记的变量所占的内存。</p><blockquote><p>标记清除之所以不存在循环引用的问题，是因为当函数执行完毕之后，对象A和B就已经离开了所在的作用域，此时两个变量被标记为“离开环境”，等待被垃圾收集器回收，最后释放其内存。</p></blockquote><h3 id="管理内存"><a class="header-anchor" href="#管理内存"></a>管理内存</h3><p>使用具备垃圾收集机制的语言编写程序，开发人员一般都不必担心内存管理的问题。但JavaScript在进行内存管理以及垃圾收集时面临的问题还是有些不同。出于安全方面的考虑，系统分配给浏览器的可用内存数量通常要比分配给桌面应用程序的少，防止JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。<br>因此为了确保占用最少的内存可以让页面获取更好的性能。优化内存占用的最佳方式就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用，即解除引用。这一做法适用于大多全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。（具体请阅读《JavaScript高级程序设计》第四章）</p><p>可以分析以下代码：</p><pre><code class="language-js">    function createPerson(name){        var localPerson = new Object();        localPerson.name = name;        return localPerson;    }    var globalPerson = createPerson(&quot;Junga&quot;);    globalPerson = null;//手动解除全局变量的引用</code></pre><p>在这个🌰中，变量globalPerson取得了createPerson()函数的返回的值。在createPerson()的内部创建了一个局部变量localPerson并添加了一个name属性。由于localPerson在函数执行完毕之后就离开执行环境，因此会自动解除引用，而对于全局变量来说则需要我们手动设置null，解除引用。</p><blockquote><p>不过，解除一个值的引用并不意味着自动回收该值所占用的内存，解除引用真正的作用是让值脱离执行环境，以便垃圾收集器下次运行时将其收回。</p></blockquote><h2 id="内存优化"><a class="header-anchor" href="#内存优化"></a>内存优化</h2><blockquote><p>对于全局变量，JavaScript不能确定它在后面不能够被用到，所以它会从声明之后就一直存在于内存中，直至手动释放或者关闭页面/浏览器，这就导致了某些不必要的内存消耗。我们可以进行以下的优化:</p></blockquote><h3 id="立即执行函数的运用"><a class="header-anchor" href="#立即执行函数的运用"></a>立即执行函数的运用</h3><pre><code class="language-js">  ;(function(window, $, undefined) {      // 主业务代码   })(window, jQuery);</code></pre><p>立即执行函数的作用就是建立一个独立的作用域，其一是为了防止全局污染，同时也可以防止过多的定义全局变量造成的内存回收问题。如果你的某些变量真的需要一直存在可以通过上面的方法挂载在window下。同样，你也可以传入jQuery进行使用。</p><h3 id="手动解除变量的引用"><a class="header-anchor" href="#手动解除变量的引用"></a>手动解除变量的引用</h3><pre><code class="language-js">  var obj = {a:1,b:2,c:3};  obj = null;</code></pre><h3 id="使用回调"><a class="header-anchor" href="#使用回调"></a>使用回调</h3><p>除了使用闭包进行内部变量访问，回调函数也有这个功能。</p><pre><code class="language-js">  function getData(callback) {    var data = 'Junga';    callback(data);  }  getData(function(data) {    console.log(data);  });</code></pre><p>回调函数是一种后续传递风格(Continuation Passing Style, CPS)的技术，这种风格的程序编写将函数的业务重点从返回值转移到回调函数中去。而且其相比闭包的好处也不少：</p><ol><li>如果传入的参数是基础类型（如字符串、数值），回调函数中传入的形参就会是复制值，业务代码使用完毕以后，更容易被回收；</li><li>通过回调，我们除了可以完成同步的请求外，还可以用在异步编程中，这也就是现在非常流行的一种编写风格；</li><li>回调函数自身通常也是临时的匿名函数，一旦请求函数执行完毕，回调函数自身的引用就会被解除，自身也得到回收。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于js事件循环的那点一知半解</title>
      <link href="/2017/02/17/event-Loop/"/>
      <url>/2017/02/17/event-Loop/</url>
      
        <content type="html"><![CDATA[<h1>起源</h1><p>最近在回顾一些知识点，也解惑了一些之前不懂的知识点，在这个过程中也饶有兴致的搞了一个个人博客，现在看来还不错，即可以总结记录一些知识点，又可以分享，虽然现在是给自己的看到哈哈哈~~~</p><p>其中在网上看到了一道面试题，跟之前去某公司给的一道面试题一毛一样，涉及到的是长数组递归可能造成js的堆栈溢出，而后又从堆栈溢出引申了解到了JS的事件循环，总算是对此有了一知半解。</p><a id="more"></a><p>先看看下面这道面试题：</p><blockquote><p>如果 list 很大，下面的这段递归代码会造成堆栈溢出。如果在不改变递归模式的前提下修善这段代码:</p></blockquote><pre><code class="language-js">    var list = readHugeList();    var nextListItem = function() {        var item = list.pop();        if (item) {                // process the list item...            nextListItem();        }    };</code></pre><p>之前是刚毕业不久去某公司碰到的一道面试题，当时对js的一些知识掌握的不是很深刻，这道题完全不知道怎么去解决？后面这道就没写，最后面试以失败告终。不过那次之后也发现自己的不足，任重而道远啊。其他废话不多说了，进入正题吧！</p><blockquote><p>上面那道题的答案是加一个setTimeout的定时器：</p></blockquote><pre><code class="language-js">    var list = readHugeList();    var nextListItem = function() {        var item = list.pop();        if (item) {            // process the list item...            setTimeout( nextListItem, 0);        }    };</code></pre><p>之后还是有些困惑不解，后面查了一些资料之后，原来涉及到了JavaScript的事件循环机制。</p><h2 id="js的事件循环机制"><a class="header-anchor" href="#js的事件循环机制"></a>JS的事件循环机制</h2><p>我们都知道，JS是单线程的编程语言，即在js运行时，所有的任务是一个队列，只有前一个任务完成了，下一个任务才会继续执行。因此，如果前面一个任务耗时很长，那么下一个任务就要长时间等待，可想而知，这样的处理任务效率非常低。</p><p>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</p><p>由此，JavaScript的运行机制可以简单理解为一个主线程和一个任务队列，脚本运行时先运行主线程，主线程运行完后，从”任务队列”中读取事件，运行任务队列的任务，这个过程是循环不断的，又称Event Loop（事件循环）。注意只要主线程的任务没有运行完，异步队列中的任务永远也无法运行，所以会导致浏览器出现假死的情况。我们可以看一下图解（转引自阮老师的<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a>）。</p><div align="center">    <img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png" alt="图解"></div><h2 id="解决"><a class="header-anchor" href="#解决"></a>解决</h2><p>所谓的事件循环不是单纯只有JS的事件类型去触发，类似setTimeout开启的延时线程，当主线程运行之后，在一定的时间会触发setTimeout的异步任务，此时任务便从消息队列移除进入主线程完成执行，所以setTimeout亦可以看做是由时间的长短来定时触发的一种事件.</p><p>我们来看下面的代码：</p><pre><code class="language-js">    console.log('a');    setTimeout(function(){        console.log('b');    },0);    console.log('c');</code></pre><p>上述运行结果依次输出的是 acb；原因是js执行时同步加以上任务放入主线程，而遇到setTimeout之后开启了一个延时线程，进入了异步任务队列，等到主线程的任务都完成之后，再读取任务队列，所以输出的结果是acb。<br>需要进一步解释的是：这里的零延迟不是说setTimeout会被立刻执行，是说等到主线程执行完成，并且任务队列中没有其他任务时，setTimeout的回调函数才会被执行，最重要的一点就是setTimeout设置的时间并非回调函数会在这个时间间隔之后立即运行，仅仅表示的是最少时间而非确切的时间，因为主线程任务需要执行完成为空时，才会处理任务队列的消息处理即回调函数，所以setTimeout执行回调函数所等待的时间比它设定的时间参数要长。</p><p>现在我们可以回过头去解释刚开始那道用setTimeout来解决内存溢出的面试题:</p><blockquote><p>在没有用setTimeout进行递归时，当数组过大，不断进行递归调用，主线程的任务数量会不断叠加，当达到一定大小就会造成堆栈溢出，而当递归函数放到setTimeout进行异步执行，此时相当于开了另外一个延时线程，主线程就负责调用setTimeout这个异步线程执行任务就可以，一执行完成就释放，就不会造成堆栈溢出。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS之清除浮动</title>
      <link href="/2017/02/16/css-clearFloat/"/>
      <url>/2017/02/16/css-clearFloat/</url>
      
        <content type="html"><![CDATA[<p>面试的时候，关于清除浮动的问题经常会被考察，一开始对清除浮动了解不深，只知道css有个clear属性。在平时开发中也经常会用到float布局方式，之前因为了解不深，所以使用这种布局的时候经常出现问题。后面查找资料才发现原来清除浮动后面大有学问，了解清除浮动有利于我们对布局的开发，下面是对了解之后作出的一些总结，可能总结的不全面。</p><p>在了解清除浮动之前，先看下什么是BFC。</p><a id="more"></a><h1>了解BFC</h1><p>首先看看W3C对BFC是怎么定义的：</p><blockquote><p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.<br>In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.<br>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).</p></blockquote><p>翻译过来就是：</p><blockquote><p>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的块级格式化上下文。<br>在一个块级格式化上下文里，盒子从包含块的顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。两个相邻的块级盒子的垂直外边距会发生叠加。<br>在块级格式化上下文中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘），即使存在浮动也是如此，除非这个盒子创建一个新的块级格式化上下文。</p></blockquote><p>BFC就是“块级格式化上下文”的意思，创建了BFC的元素就是一个独立的盒子，不过只有Block-level box可以参与创建BFC，它规定了内部的Block-level Box如何布局，并且与这个独立盒子里的布局不受外部影响，当然它也不会影响到外面的元素。</p><h2 id="bfc的特性"><a class="header-anchor" href="#bfc的特性"></a>BFC的特性</h2><ul><li>内部的Box会在垂直方向，从顶部开始一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生叠加</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box叠加。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。</li><li>计算BFC的高度时，浮动元素也参与计算。</li></ul><h2 id="触发bfc的属性"><a class="header-anchor" href="#触发bfc的属性"></a>触发BFC的属性</h2><ul><li>float 除了none以外的值</li><li>overflow 除了visible 以外的值（hidden，auto，scroll ）</li><li>display (table-cell，table-caption，inline-block, flex, inline-flex)</li><li>position值为（absolute，fixed）</li></ul><h1>清除浮动</h1><p>在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。</p><blockquote><p>清除浮动的本质就是让元素标签闭合，即触发其BFC,所以以上可以触发BFC的可以清除浮动,此外css还有一个clear属性也可以清除浮动</p></blockquote><h2 id="方法"><a class="header-anchor" href="#方法"></a>方法</h2><p>方法一：使用额外标签法，即使用带clear属性的空元素</p><p>优点：简单，代码少，浏览器兼容性好。</p><p>缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。</p><pre><code class="language-html">.box {  background-color: gray;  border: solid 1px black;  }.box img {  float: left;  }.box p {  float: right;  }.clear {  clear: both;  }&lt;div class=&quot;box&quot;&gt;    &lt;img src=&quot;news-pic.jpg&quot; /&gt;    &lt;p&gt;some text&lt;/p&gt;    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>方法二：利用CSS的overflow属性</p><p>给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。明显的缺点是当容器内部的内容过多时会被隐藏</p><pre><code class="language-html">.box {  background-color: gray;  border: solid 1px black;  overflow: hidden;  *zoom: 1;  }.box img {  float: left;  }.box p {  float: right;  }&lt;div class=&quot;box&quot;&gt;    &lt;img src=&quot;news-pic.jpg&quot; /&gt;    &lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;</code></pre><p>方法三：给浮动的元素的容器添加浮动</p><p>给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。</p><p>方法四：给父元素定高</p><p>父容器因为子元素浮动造成高度撑不开，可以给父元素定高度，缺点明显是当父容器高度固定了，不够灵活。</p><p>方法五：使用css的:after伪元素（现在项目中清除浮动就是采用这种方法，兼容性跟友好性都比较好）</p><p>after伪元素和zoom：1结合可以解决当前绝大多数浏览器浮动问题，zoom:1可以触发IE的hasLayout，具体实现代码如下：</p><pre><code class="language-html">.box {  background-color: gray;  border: solid 1px black;  overflow: hidden;  *zoom: 1;  }.box img {  float: left;  }.box p {  float: right;  }.clearfix:after{  content: &quot;.&quot;;   display: block;   height: 0;   clear: both;   visibility: hidden;    }.clearfix {  /* 触发 hasLayout */   zoom: 1;  }&lt;div class=&quot;box clearfix&quot;&gt;    &lt;img src=&quot;news-pic.jpg&quot; /&gt;    &lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;</code></pre><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>通过上面的例子，清除浮动的方法可以分成两类：<br>一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。<br>二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一个个人博客</title>
      <link href="/2017/02/15/hello-world/"/>
      <url>/2017/02/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>最近一直有个想搞个个人博客玩玩的想法，今天在网上看到一个静态博客框架Hexo，于是看教程学着搭建了一个，现在看起来很成功，哈哈！开启我的博客之旅吧！</p><div align="center"><img src="http://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-3.gif" alt="图文"></div><a id="more"></a><h2 id="安装前系统所需要的工具"><a class="header-anchor" href="#安装前系统所需要的工具"></a>安装前系统所需要的工具</h2><h3 id="1-git"><a class="header-anchor" href="#1-git"></a>1、Git</h3><p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Hexo就是将你的博客项目上传托管到git,通过github来访问你的个人博客了。</p><h3 id="2-node"><a class="header-anchor" href="#2-node"></a>2、Node</h3><p>因为Hexo是一款基于Node.js的静态博客框架，所以我们还需要安装好它。</p><h3 id="3-hexo"><a class="header-anchor" href="#3-hexo"></a>3、Hexo</h3><p>安装好Git和Node.js之后，轮到我们今天的主角登场了~先打开Git Bash，然后输入下面这条命令来安装Hexo：</p><pre><code class="language-bash">$ npm install hexo-cli -g</code></pre><p>安装完输入以下命令查看版本信息：</p><pre><code class="language-bash">$ hexo -v</code></pre><p>如果出现类似以下内容的则安装成功</p><pre><code class="language-bash">hexo: 3.2.2hexo-cli: 1.0.2os: Darwin 16.1.0 darwin x64http_parser: 2.7.0node: 6.9.1v8: 5.1.281.84uv: 1.9.1zlib: 1.2.8ares: 1.10.1-DEVicu: 57.1modules: 48openssl: 1.0.2j</code></pre><p>接下来就可以用Hexo愉快的zhuangbility了！！！</p><h2 id="创建属于自己的博客"><a class="header-anchor" href="#创建属于自己的博客"></a>创建属于自己的博客</h2><h3 id="初始化hexo创建博客模板"><a class="header-anchor" href="#初始化hexo创建博客模板"></a>初始化hexo创建博客模板</h3><p>在本地创建一个文件夹，比如blog,进入文件夹执行以下命令：</p><pre><code class="language-bash"> $ hexo init</code></pre><p>执行完成之后可以在blog文件下看到博客相关的配置文件~~~</p><h3 id="配置github"><a class="header-anchor" href="#配置github"></a>配置github</h3><p><a href="http://blog.csdn.net/yuexianchang/article/details/53431703" target="_blank" rel="noopener">建立<em>Repository</em></a>，建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，然后与本地blog建立关联，<br>关联之前首先配置一下blog根目录下的_config.yml文件：</p><pre><code class="language-bash"> deploy:     type: git     repo: 你创建的博客所在的仓库github路径     branch: master</code></pre><p>然后执行以下命令：其中hexo g是生成静态页面至public目录，hexo deploy #将.deploy目录部署到GitHub</p><pre><code class="language-bash">$ npm install hexo-deployer-git --save$ hexo g$ hexo d</code></pre><p>一些常用的命令：</p><pre><code class="language-bash">hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本</code></pre><p>至此，<a href="http://xn--username-sc0mo0cqns1cba863lz7bgv9ct7lbice7v1n2he10e.github.io" target="_blank" rel="noopener">你可以打开你的个人博客路径username.github.io</a>，就可以看到你的博客了。</p><blockquote><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">更加详细的教程前往hexo的中文官网查看</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
