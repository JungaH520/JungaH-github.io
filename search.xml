<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅析Vue3数据响应系统]]></title>
    <url>%2F2019%2F10%2F11%2Fabout-vue3-proxy%2F</url>
    <content type="text"><![CDATA[国庆长假还没结束，尤大大就把Vue3源码给放了出来，还能不能好好让人好好放个假😨，目前的版本还是 Pre-Alpha，源码地址：Vue-next， 而正式版本可能要明年才发布了，于是放假回来，便第一时间clone了源码，生啃了起来，还别说，真香~~~😂 源码整体结构还是比较清晰，相比较于Vue2.x做了比较大的调整，代码话说98%都是用ts编写，所以看源码还需要大概了解ts的一些知识。而在还没发布Vue3源码之前，官网也已经给出了 Vue Composition API RFC，可以初步了解Vue3的一些写法和特性，这两天花了些时间大概看了下数据响应部分（网上已经有大佬给出了调试技巧） 熟悉Vue2.x的童鞋应该知道，其数据响应是基于 ES5 的API Object.defineProperty 来操作属性的 getter/setter 实现的，本身API存在一些不足：比如对于数组，不能通过数组下标来观测其变化，也不能观测数组长度length的变化，为此对数组7个原生方法做了拦截处理实现对数组的观测。对于对象，由于defineProperty的局限性，Vue2不能检测对象属性的添加或删除。 为了优化解决这些不足，更好的实现方式是通过 ES6 提供的 Proxy 对象。 Vue3就是基于 Proxy 对其数据响应系统进行了重写，现在这部分可以作为独立的模块配合其他框架使用。数据响应可分为三个阶段：初始化阶段 --&gt; 依赖收集阶段 --&gt; 数据响应阶段 Proxy代理须知 用 Proxy 做代理时，我们需要了解几个问题： 1、Proxy 代理是如何对其 trap 进行处理来实现数据响应的？也就是其 get/set 里面是如何做拦截处理（其实这里的trap默认行为可以通过 Reflect 来返回，Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。这里具体可以查看阮大神的ES6入门） 2、Proxy 代理的对象只能代理到第一层，当代理的对象多层嵌套时，那么对象内部的深度监测需要如何去实现？ 3、当代理对象是数组时，比如push操作会触发多次 get/set，因为push操作除了增加数组的数据项之外，也会引发数组本身其他相关属性的改变，因此会多次触发 get/set ，那么要如何解决呢？ 下面我们会稍微分析下Vue3针对这几个问题做了哪些优化处理。 初始化阶段 初始化过程相对比较简单，通过 reactive() 方法将数据转化成 Proxy 对象，这里注意一个比较重要的对象 targetMap，它在依赖收集阶段起着比较重要的作用，具体下面会有分析。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758export function reactive(target: object) &#123; // if trying to observe a readonly proxy, return the readonly version. if (readonlyToRaw.has(target)) &#123; return target &#125; // target is explicitly marked as readonly by user if (readonlyValues.has(target)) &#123; return readonly(target) &#125; return createReactiveObject( target, rawToReactive, reactiveToRaw, mutableHandlers, mutableCollectionHandlers )&#125;...// 创建proxy对象function createReactiveObject( target: any, toProxy: WeakMap&lt;any, any&gt;, toRaw: WeakMap&lt;any, any&gt;, baseHandlers: ProxyHandler&lt;any&gt;, collectionHandlers: ProxyHandler&lt;any&gt;) &#123; if (!isObject(target)) &#123; if (__DEV__) &#123; console.warn(`value cannot be made reactive: $&#123;String(target)&#125;`) &#125; return target &#125; // target already has corresponding Proxy let observed = toProxy.get(target) if (observed !== void 0) &#123; return observed &#125; // target is already a Proxy if (toRaw.has(target)) &#123; return target &#125; // only a whitelist of value types can be observed. if (!canObserve(target)) &#123; return target &#125; const handlers = collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers observed = new Proxy(target, handlers) toProxy.set(target, observed) toRaw.set(observed, target) if (!targetMap.has(target)) &#123; targetMap.set(target, new Map()) &#125; return observed&#125; Vue3如何进行深度观测的？先看下面这段代码 1234567891011121314151617let data = &#123; x: &#123;y: &#123;z: 1 &#125; &#125; &#125;let p = new Proxy(data, &#123; get(target, key, receiver) &#123; const res = Reflect.get(target, key, receiver) console.log('get value:', key) console.log(res) return res &#125;, set(target, key, value, receiver) &#123; console.log('set value:', key, value) return Reflect.set(target, key, value, receiver) &#125;&#125;)p.x.y = 2// get value: x// &#123;y: 2&#125; 上面代码我们可以知道 Proxy 只会代理一层，因为这里只是触发了一次最外层属性 x 的 get，而重新赋值的其内部属性 y，此时 set 并没有被触发，所以改变内部属性是不会监测到的。继续看，Reflect.get返回的结果正是 target 的内层结构，此时p.x.y的值也已经变成2了，我们可以判断当前 Reflect.get 返回的值是否为object，若是则再通过 reactive 做代理，这样就达到了深度观测的目的了。 Vue3实现过程具体我们可以看下面源码： 1234567891011121314151617181920function createGetter(isReadonly: boolean) &#123; return function get(target: any, key: string | symbol, receiver: any) &#123; const res = Reflect.get(target, key, receiver) if (typeof key === 'symbol' &amp;&amp; builtInSymbols.has(key)) &#123; return res &#125; if (isRef(res)) &#123; return res.value &#125; track(target, OperationTypes.GET, key) // 当代理的对象是多层结构时，Reflect.get会返回对象的内层结构，我们可以拿到当前res再做判断是否为object，进而进行reactive，就达到了深度观测的目的了 return isObject(res) ? isReadonly ? // need to lazy access readonly and reactive here to avoid // circular dependency readonly(res) : reactive(res) : res &#125;&#125; 依赖收集阶段 所谓的依赖在Vue3可简单理解为各种 effect 响应式函数，其中包括了属性依赖的effect，计算属性 computedEffect 以及组件视图的 componentEffect 1、在视图挂载渲染时会执行一个 componentEffect，触发相关数据属性getter操作来完成视图依赖收集。 2、effect函数执行也会触发相关属性的getter操作，此时操作了某个属性的effect也会被该属性对应进行收集（注意这里的属性是可观测的）。 之所以说是响应式的，是因为effect方法回调中关联了被观测的数据属性，而effect一般是立即执行的，此时触发了该属性的 getter，进行依赖收集，当该属性触发 setter 时，便会触发执行收集的依赖。另外，这里每次effect执行时，当前的effect会被压入一个名为 activeReactiveEffectStack 的栈中，是在依赖收集的时候使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152export function effect( fn: Function, options: ReactiveEffectOptions = EMPTY_OBJ): ReactiveEffect &#123; if ((fn as ReactiveEffect).isEffect) &#123; fn = (fn as ReactiveEffect).raw &#125; const effect = createReactiveEffect(fn, options) if (!options.lazy) &#123; // effect立即执行，触发effect回调函数fn中相关响应数据属性的getter操作，从而进行依赖收集 effect() &#125; return effect&#125;...// 触发getter操作，进行依赖收集export function track( target: any, type: OperationTypes, key?: string | symbol) &#123; if (!shouldTrack) &#123; return &#125; const effect = activeReactiveEffectStack[activeReactiveEffectStack.length - 1] if (effect) &#123; if (type === OperationTypes.ITERATE) &#123; key = ITERATE_KEY &#125; let depsMap = targetMap.get(target) if (depsMap === void 0) &#123; targetMap.set(target, (depsMap = new Map())) &#125; let dep = depsMap.get(key!) if (dep === void 0) &#123; depsMap.set(key!, (dep = new Set())) &#125; // 防止依赖重复收集 if (!dep.has(effect)) &#123; dep.add(effect) effect.deps.push(dep) if (__DEV__ &amp;&amp; effect.onTrack) &#123; effect.onTrack(&#123; effect, target, type, key &#125;) &#125; &#125; &#125;&#125; 开头说过 targetMap 对象在依赖收集过程中的重要作用，看源码我们大概知道了，它维护了一个依赖收集的关系表，targetMap 是一个 WeakMap，其 key 值是当前被代理的对象 target，而 value 则是该对象所对应的 depsMap，它是一个 Map，key 值为触发 getter 时的属性值，而 value 值则是触发过该属性值所对应的各个 effect。 故 targetMap 的关系映射可以看成 target --&gt; key --&gt; effect，可以看出 target 被观测后，其属性 key 在被触发 getter 操作时，收集了所依赖的 effect，可以说 targetMap 是Vue3进行依赖收集的一个核心对象。 响应阶段 当触发属性 setter 时，通过 trigger 函数会执行属性对应收集的 effects，也包括 computedEffects，此时通过 scheduleRun 逐个调用 effect，最后完成视图更新。 上面我们讲过监测数组的时候可能触发多次 get/set, 那么如何防止触发多次的呢？先看Vue3的源码(简写省略了部分代码)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// setter操作触发响应function set( target: any, key: string | symbol, value: any, receiver: any): boolean &#123; value = toRaw(value) // 判断key是否为当前target自身属性 const hadKey = hasOwn(target, key) // 获取旧值 const oldValue = target[key] if (isRef(oldValue) &amp;&amp; !isRef(value)) &#123; oldValue.value = value return true &#125; const result = Reflect.set(target, key, value, receiver) ... if (!hadKey) &#123; // 若属性不存在标记为add操作 trigger(target, OperationTypes.ADD, key) &#125; else if (value !== oldValue) &#123; // 若值不相等在触发，并且标记为set操作 trigger(target, OperationTypes.SET, key) &#125; ... return result&#125;export function trigger( target: any, type: OperationTypes, key?: string | symbol, extraInfo?: any) &#123; const depsMap = targetMap.get(target) if (depsMap === void 0) &#123; // never been tracked return &#125; const effects = new Set&lt;ReactiveEffect&gt;() const computedRunners = new Set&lt;ReactiveEffect&gt;() // 这里遍历找出相关依赖的effect if (type === OperationTypes.CLEAR) &#123; // collection being cleared, trigger all effects for target depsMap.forEach(dep =&gt; &#123; addRunners(effects, computedRunners, dep) &#125;) &#125; else &#123; // schedule runs for SET | ADD | DELETE if (key !== void 0) &#123; addRunners(effects, computedRunners, depsMap.get(key)) &#125; // also run for iteration key on ADD | DELETE if (type === OperationTypes.ADD || type === OperationTypes.DELETE) &#123; // 这里当改变数组length长度时也会触发相关effect进行响应 const iterationKey = Array.isArray(target) ? 'length' : ITERATE_KEY addRunners(effects, computedRunners, depsMap.get(iterationKey)) &#125; &#125; // 遍历执行依赖的effect const run = (effect: ReactiveEffect) =&gt; &#123; scheduleRun(effect, target, type, key, extraInfo) &#125; computedRunners.forEach(run) effects.forEach(run)&#125;function scheduleRun( effect: ReactiveEffect, target: any, type: OperationTypes, key: string | symbol | undefined, extraInfo: any) &#123; ... if (effect.scheduler !== void 0) &#123; effect.scheduler(effect) &#125; else &#123; effect() &#125;&#125; 由源码我们可以分析出：1、判断key是否为当前被代理对象target自身属性; 2、判断旧值与新值是否相等。只有这两个条件其中一个满足，才有可能执行 trigger。 怎么理解呢，我们举个🌰，可以实现一个小的 reactive 方法来做数据代理，代码如下： 1234567891011121314151617181920212223242526272829303132333435function hasOwn(val, key) &#123; const hasOwnProperty = Object.prototype.hasOwnProperty return hasOwnProperty.call(val, key)&#125;function reactive(data) &#123; let observed = new Proxy(data, &#123; get(target, key, receiver) &#123; const res = Reflect.get(target, key, receiver) return res &#125;, set(target, key, value, receiver) &#123; console.log(target, key, value) const hadKey = hasOwn(target, key) const oldValue = target[key] const result = Reflect.set(target, key, value, receiver) if (!hadKey) &#123; console.log('trigger add operation...') &#125; else if(value !== oldValue) &#123; console.log('trigger set operation...') &#125; return result &#125; &#125;) return observed&#125;let data = ['a', 'b']let state = reactive(data)state.push('c')// ["a", "b"] "2" "c"// trigger add operation...// ["a", "b", "c"] "length" 3 state.push(‘c’) 会触发两次 set ，一次是push的值 c ，一次是 length 属性设置。 1、设置值 c 时，新增了索引 key 为 2，*target 是原始的代理对象 [‘a’, ‘c’] ，这是一个 add 操作, 故 hasOwn(target, key) 返回的是false，此时执行 trigger add operation… 。注意在Vue源码trigger方法中，length没有对应的effect，所以就没有执行相关的effect 2、当传入 key 为 length 时，length 是自身属性，故 hasOwn(target, key) 返回 true, 此时 value 是 3, 而 oldValue 即为 target[‘length’] 也是 3，故value !== oldValue不成立，不执行trigger方法 故只有当 hasOwn(target, key) 返回true或者 value !== oldValue 的时候才执行 trigger 总结 在分析源码之前我们先列举了用Proxy做代理实现数据响应需要解决的几个问题，并带着这些问题一步一步揭开Vue在数据响应系统处理这些问题的面纱，也让我们进一步了解了Vue源码编写有许多巧妙的地方，比如利用 Reflect.get 返回值为 target 当前触发的第一层属性 key 值对应的 value 值，从而再来判断是否为Object来进行深度观测，并且观测的值存放在一个WeakMap下，这样相比较递归Proxy，Vue的这种实现方式大大提高了数据响应的性能。 这两天就大致的阅读了这部分源码，有些细节地方还没去深入理解，存在不足或者错误的地方还请各位大佬指出，大家一起学习交流哈。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端开发问题小记]]></title>
    <url>%2F2019%2F07%2F03%2Fabout-mobile-develop%2F</url>
    <content type="text"><![CDATA[关于ios键盘挡住问题（适用于input置底，键盘弹起窗口可滚动） 12345678910111213141516171819202122232425262728293031323334/** * 解决ios键盘被挡住input问题，适用于input置底，键盘弹起窗口可滚动 * @param &#123;*&#125; input input类名或选择器 */ repairIosInputHidden(input) &#123; if (this.isIos()) &#123; const inputEl = typeof input === 'string' ? document.querySelector(input) : input; let timeout = null; // 记录窗口滚动前的滚动高度 const scrollElement = document.scrollingElement || document.body || document.documentElement; const bfscrolltop = scrollElement.scrollTop || window.pageYOffset; const setScrollTop = (h) =&gt; &#123; scrollElement.scrollTop = h; &#125;; const scrollToBottom = () =&gt; &#123; const scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight; setScrollTop(scrollHeight); &#125;; // input聚焦键盘弹起，获取窗口可滚动高度scrollHeight，延时赋值，此时已经是最大可滚动高度了， // 即键盘弹出后滚动条会滚动到底部，input会显示在键盘之上 inputEl.onfocus = () =&gt; &#123; // 让input显示在可视区域，兼容部分机型原生键盘挡住问题 inputEl.scrollIntoView(true); timeout = setTimeout(() =&gt; &#123; scrollToBottom(); &#125;, 300); &#125;; // input失去焦点后，恢复原来滚动位置 inputEl.onblur = () =&gt; &#123; clearTimeout(timeout); setScrollTop(bfscrolltop); &#125;; &#125; &#125; 点击双击事件并存 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div class="touch-wrapper" @click.stop="onTap"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;let lastClickTime = 0;let clickTimer;export default &#123; name: 'BaseTouch', props: &#123; // 单击事件延迟时间 delay: &#123; type: Number, default: 300 &#125; &#125;, methods: &#123; onTap(e) &#123; const nowTime = new Date().getTime(); // 在规定时间内再触发点击事件时执行doubleTap，即此时为双击事件，否则为单击事件 if (nowTime - lastClickTime &lt; this.delay) &#123; lastClickTime = 0; if (clickTimer) &#123; clearTimeout(clickTimer); &#125; this.$emit('double-tap', e); &#125; else &#123; lastClickTime = nowTime; clickTimer = setTimeout(() =&gt; &#123; this.$emit('tap', e); &#125;, this.delay); &#125; &#125; &#125;&#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>移动端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise原理小记]]></title>
    <url>%2F2019%2F02%2F26%2Fabout-promise%2F</url>
    <content type="text"><![CDATA[定义 Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。 Promise：为构造函数，接受一个函数作为参数，该函数接收resolve和reject两个参数，由JavaScript引擎提供，无需自己实现。 resolve：其作用是将Promise对象的状态从Pending变为Resolved,在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject：其作用是将Promise对象的状态从从Pending变为Rejected,在异步操作失败时调用，并将异步操作抛出的错误，作为参数传递出去。 Promise对象只有三种状态: 未完成：pending 已完成：resolved(也称fulfilled) 失败：rejected 以上三种状态只有以下两种变化,一旦当前状态变为“resolved”或“rejected”，就意味着不会再有新的状态变化： pending-&gt;resolved pending-&gt;rejected then(onFulfilled, onRjected)：then方法传递两个函数作为参数，当Promise状态为fulfilled时，调用 then 的 onFulfilled 方法，当Promise状态为rejected时，调用 then 的 onRjected 方法。 catch(onRjected)：当Promise状态为rejected时，调用 then 的 onRjected 方法。 例子： 1234567891011121314151617let p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; let num = Math.random() if (num &gt; 0.5) &#123; resolve(num) &#125;else&#123; reject(num) &#125; &#125;, 1000)&#125;)p.then(function(num)&#123; console.log('大于0.5的数字：', num)&#125;,function(num)&#123; console.log('小于等于0.5的数字', num)&#125;)// 运行第一次：小于等于0.5的数字 0.166162996031475// 运行第二次：大于0.5的数字： 0.6591451548308984 原理 根据以上内容，Promise对象作为一个构造函数，并接受一个函数作为参数，该函数执行完同步或异步操作后，调用它的两个参数resolve和reject，，同时其内部有状态机制，原型链上有then方法，故可先初步实现Promise的功能，如下： 123456789101112131415161718192021222324252627282930function Promise(executor)&#123; //executor是一个执行器（函数） let _this = this // 先缓存this以免后面指针混乱 _this.status = 'pending' // 默认状态为等待态 _this.value = undefined // 成功时要传递给成功回调的数据，默认undefined _this.reason = undefined // 失败时要传递给失败回调的原因，默认undefined function resolve(value) &#123; // 内置一个resolve方法，接收成功状态数据 // 上面说了，只有pending可以转为其他状态，所以这里要判断一下 if (_this.status === 'pending') &#123; _this.status = 'resolved' // 当调用resolve时要将状态改为成功态 _this.value = value // 保存成功时传进来的数据 &#125; &#125; function reject(reason) &#123; // 内置一个reject方法，失败状态时接收原因 if (_this.status === 'pending') &#123; // 和resolve同理 _this.status = 'rejected' // 转为失败态 _this.reason = reason // 保存失败原因 &#125; &#125; executor(resolve, reject) // 执行执行器函数，并将两个方法传入&#125;// then方法接收两个参数，分别是成功和失败的回调，这里我们命名为onFulfilled和onRjectedPromise.prototype.then = function(onFulfilled, onRjected)&#123; let _this = this; // 依然缓存this if(_this.status === 'resolved')&#123; // 判断当前Promise的状态 onFulfilled(_this.value) // 如果是成功态，当然是要执行用户传递的成功回调，并把数据传进去 &#125; if(_this.status === 'rejected')&#123; // 同理 onRjected(_this.reason) &#125;&#125; 测试下： 1234567891011121314151617181920212223// 成功let Promise = require('./myPromise') // 引入模块let p = new Promise(function(resolve, reject)&#123; resolve('test')&#125;)p.then(function(data)&#123; console.log('成功', data)&#125;,function(err)&#123; console.log('失败', err)&#125;)// 成功 test// 失败let Promise = require('./myPromise') // 引入模块let p = new Promise(function(resolve, reject)&#123; reject('test')&#125;)p.then(function(data)&#123; console.log('成功', data)&#125;,function(err)&#123; console.log('失败', err)&#125;)// 失败 test 以上可以看到Promise传入参数的函数是立刻执行的，当传入的函数执行异步操作时，这个时候then方法中回调是不会异步执行的，即此时获取不到任何结果，例如： 1234567891011let p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; resolve(100) &#125;, 1000)&#125;)p.then(function(data)&#123; console.log('成功', data)&#125;,function(err)&#123; console.log('失败', err)&#125;)// 不会输出任何代码 原因是then只是对成功或者失败状态进行了判断，而Promise实例化时，传入的函数会立即执行，而setTimeout是异步执行的，当then方法执行的时候，此时Promise的状态还是pendding，因此也需要对pendding状态进行判断，此时我们可以在then方法中判断pendding状态，先获取保存回调函数，等到异步函数执行再一一执行then方法中的回调函数，改进后的代码如下： 实现异步 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// myPromisefunction Promise(executor)&#123; //executor是一个执行器（函数） let _this = this // 先缓存this以免后面指针混乱 _this.status = 'pending' // 默认状态为等待态 _this.value = undefined // 成功时要传递给成功回调的数据，默认undefined _this.reason = undefined // 失败时要传递给失败回调的原因，默认undefined /**add: 用来存放then回调函数**/ _this.onResolvedCallbacks = []; // 存放then成功的回调 _this.onRejectedCallbacks = []; // 存放then失败的回调 /**add**/ function resolve(value) &#123; // 内置一个resolve方法，接收成功状态数据 // 上面说了，只有pending可以转为其他状态，所以这里要判断一下 if (_this.status === 'pending') &#123; _this.status = 'resolved' // 当调用resolve时要将状态改为成功态 _this.value = value // 保存成功时传进来的数据 /**add**/ _this.onResolvedCallbacks.forEach(function(fn)&#123;// 当成功的函数被调用时，之前缓存的回调函数会被一一调用 fn() &#125;) &#125; &#125; function reject(reason) &#123; // 内置一个reject方法，失败状态时接收原因 if (_this.status === 'pending') &#123; // 和resolve同理 _this.status = 'rejected' // 转为失败态 _this.reason = reason // 保存失败原因 /**add**/ _this.onRejectedCallbacks.forEach(function(fn)&#123;// 当失败的函数被调用时，之前缓存的回调函数会被一一调用 fn() &#125;) &#125; &#125; executor(resolve, reject) // 执行执行器函数，并将两个方法传入&#125;// then方法接收两个参数，分别是成功和失败的回调，这里我们命名为onFulfilled和onRjectedPromise.prototype.then = function(onFulfilled, onRjected)&#123; let _this = this; // 依然缓存this /**add: 判断pendding状态，将成功或者失败的回调函数存放到对应的数组中**/ if(_this.status === 'pending')&#123; _this.onResolvedCallbacks.push(function()&#123; onFulfilled(_this.value) &#125;) _this.onRejectedCallbacks.push(function()&#123; onRjected(_this.reason) &#125;) &#125; /**add**/ if(_this.status === 'resolved')&#123; // 判断当前Promise的状态 onFulfilled(_this.value) // 如果是成功态，当然是要执行用户传递的成功回调，并把数据传进去 &#125; if(_this.status === 'rejected')&#123; // 同理 onRjected(_this.reason) &#125;&#125;module.exports = Promise // 导出模块，否则别的文件没法使用 处理错误 Promise捕获错误执行的是reject函数，因此在实例中跑出错误时，只执行reject函数就可以，可使用try catch进行异常捕获； 12345try&#123; executor(resolve, reject)&#125; catch(e)&#123; // 如果捕获发生异常，直接调失败，并把参数穿进去 reject(e)&#125; catch方法实现 catch方法其实就是获取实例rejected方法捕获错误，相当于执行then(null, onRejected) 123Promise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected)&#125; 实现then的链式调用 上面实现的then方法其实还不完善，不能进行链式调用。是否可以跟jq一样在then方法中return this实现链式调用，可实际上Promise中then方法要复杂的多，不能简单的用return this实现链式调用。 123456789101112let p1 = new Promise(function(resolve, reject)&#123; resolve()&#125;)let p2 = p1.then(function(data)&#123; //这是p1的成功回调，此时p1是成功态 throw new Error('错误') // 如果这里抛出错误，p2应是失败态&#125;)p2.then(function()&#123;&#125;,function(err)&#123; console.log(err)&#125;)// Error: 错误 按照上面代码，如果then方法中返回的是this，那么p2跟p1相同，固状态也相同，但是Promise的成功态和失败态不能相互转换，那就不会得到p1成功而p2失败的效果，而实际上是可能发生这种情况的。因此Promise的then方法实现链式调用的原理是：返回一个新的Promise 按照这样的思路，在then方法中先定义一个新的Promise，取名为promise2，然后在三种状态下分别用promise2包装一下，在调用onFulfilled时用一个变量x（规定的）接收返回值，try…catch…一下代码，没错就调resolve传入x，有错就调reject传入错误，最后再把promise2给return出去。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 改动thenlet promise2;if (_this.status === 'resolved') &#123; promise2 = new Promise(function (resolve, reject) &#123; try &#123; let x = onFulfilled(_this.value) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;)&#125;if (_this.status === 'rejected') &#123; promise2 = new Promise(function (resolve, reject) &#123; try &#123; let x = onRjected(_this.reason) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;)&#125;if(_this.status === 'pending')&#123; promise2 = new Promise(function (resolve, reject) &#123; _this.onResolvedCallbacks.push(function()&#123; try &#123; let x = onFulfilled(_this.value) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;) _this.onRejectedCallbacks.push(function()&#123; try &#123; let x = onRjected(_this.reason) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;)&#125;return promise2 这样实现x只是当做一个普通的值，比如字符串数字数组对象等值可以用上面代码简单链式调用传给下一个then，但是如果x也是一个Promise或者是其他异步操作，可能性如下： 前一次then返回一个普通值，比如字符串数组对象等，只需传给下一个then，刚才的方法就能实现。 前一次then返回的是一个Promise，是正常的操作，也是Promise提供的语法糖，我们要想办法判断到底返回的是啥。 前一次then返回的是一个Promise，其中有异步操作，也是理所当然的，那我们就要等待他的状态改变，再进行下面的处理。 前一次then返回的是自己本身这个Promise 123var p1 = p.then(function()&#123; return p1 &#125;) 前一次then返回的是自定义的Promise的普通对象，比如{then:‘xxx’}，或者改变then方法的访问器属性，在then里故意抛错。比如 123456let promise = &#123;&#125;Object.defineProperty(promise,'then',&#123; value: function()&#123; throw new Error('报错气死你') &#125;&#125;) 在resolve传一个Promise对象 1234567p.then(function(data) &#123; return new Promise(function(resolve, reject) &#123; resolve(new Promise(function(resolve,reject)&#123; resolve(1111) &#125;)) &#125;)&#125;) 同时调用resolve和reject，则需取前面调用的方法，忽略后一个 不传任何参数，下面代码运行结果是undefined，按我们上面实现的代码，then不传任何参数时，resolve中传的值是没有办法穿透的， 123456new Promise(resolve=&gt;resolve(8)) .then() .then() .then(function foo(value) &#123; alert(value) &#125;) 针对以上问题可以对then方法代码做出优化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114Promise.prototype.then = function (onFulfilled, onRjected) &#123; //成功和失败默认不传给一个函数，解决了问题8 onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : function (value) &#123; return value; &#125; onRjected = typeof onRjected === 'function' ? onRjected : function (err) &#123; throw err; &#125; let _this = this; let promise2; //返回的promise if (_this.status === 'resolved') &#123; promise2 = new Promise(function (resolve, reject) &#123; // 当成功或者失败执行时有异常那么返回的promise应该处于失败状态 setTimeout(function () &#123;// 根据规范让那俩家伙异步执行 try &#123; let x = onFulfilled(_this.value);//这里解释过了 // 写一个方法统一处理问题1-7 resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;) &#125;) &#125; if (_this.status === 'rejected') &#123; promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; let x = onRjected(_this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;) &#125;) &#125; if (_this.status === 'pending') &#123; promise2 = new Promise(function (resolve, reject) &#123; _this.onResolvedCallbacks.push(function () &#123; setTimeout(function () &#123; try &#123; let x = onFulfilled(_this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;); _this.onRejectedCallbacks.push(function () &#123; setTimeout(function () &#123; try &#123; let x = onRjected(_this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;) &#125;); &#125;) &#125; return promise2;&#125;function resolvePromise(promise2, x, resolve, reject) &#123; // 接受四个参数，新Promise、返回值，成功和失败的回调 if (promise2 === x) &#123; //这里应该报一个类型错误，来解决问题4 return reject(new TypeError('循环引用了')) &#125; // 若返回一个promise实例 if (x instanceof Promise) &#123; // x状态没确定时即实例化时进行异步操作 if (x.status === 'pending') &#123; x.then(function(v) &#123; resolvePromise(promise2, v, resolve, reject) &#125;, reject) &#125; else &#123; // 状态确定时，直接调用then方法 x.then(resolve, reject) &#125; return &#125; // 看x是不是一个promise,promise应该是一个对象 let called; // 表示是否调用过成功或者失败，用来解决问题7 //下面判断上一次then返回的是普通值还是函数，来解决问题1、2 if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; // 可能是promise &#123;&#125;,看这个对象中是否有then方法，如果有then我就认为他是promise了 try &#123; let then = x.then;// 保存一下x的then方法 if (typeof then === 'function') &#123; // 成功 //这里的y也是官方规范，如果还是promise，可以当下一次的x使用 //用call方法修改指针为x，否则this指向window then.call(x, function (y) &#123; if (called) return //如果调用过就return掉 called = true // y可能还是一个promise，在去解析直到返回的是一个普通值 resolvePromise(promise2, y, resolve, reject)//递归调用，解决了问题6 &#125;, function (err) &#123; //失败 if (called) return called = true reject(err); &#125;) &#125; else &#123; resolve(x) &#125; &#125; catch (e) &#123; if (called) return called = true; reject(e); &#125; &#125; else &#123; // 说明是一个普通值1 resolve(x); // 表示成功了 &#125;&#125; 其他方法 12345678910111213141516171819202122232425262728293031323334353637383940414243// 捕获错误的方法，在原型上有catch方法，返回一个没有resolve的then结果即可Promise.prototype.catch = function (callback) &#123; return this.then(null, callback)&#125;// 解析全部方法，接收一个Promise数组promises,返回新的Promise，遍历数组，都完成再resolvePromise.all = function (promises) &#123; //promises是一个promise的数组 return new Promise(function (resolve, reject) &#123; let arr = []; //arr是最终返回值的结果 let i = 0; // 表示成功了多少次 function processData(index, y) &#123; arr[index] = y; if (++i === promises.length) &#123; resolve(arr); &#125; &#125; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(function (y) &#123; processData(i, y) &#125;, reject) &#125; &#125;)&#125;// 只要有一个promise成功了 就算成功。如果第一个失败了就失败了Promise.race = function (promises) &#123; return new Promise(function (resolve, reject) &#123; for (var i = 0; i &lt; promises.length; i++) &#123; promises[i].then(resolve,reject) &#125; &#125;)&#125;// 生成一个成功的promisePromise.resolve = function(value)&#123; return new Promise(function(resolve,reject)&#123; resolve(value); &#125;)&#125;// 生成一个失败的promisePromise.reject = function(reason)&#123; return new Promise(function(resolve,reject)&#123; reject(reason); &#125;)&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Async原理小记]]></title>
    <url>%2F2019%2F02%2F26%2Fabout-async%2F</url>
    <content type="text"><![CDATA[定义 async function 声明用于定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。但是如果你的代码使用了异步函数，它的语法和结构会更像是标准的同步函数。 12345678910111213141516171819function resolveAfter2Seconds() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve('resolved'); &#125;, 2000); &#125;);&#125;async function asyncCall() &#123; console.log('calling'); var result = await resolveAfter2Seconds(); console.log(result); // expected output: 'resolved'&#125;asyncCall();// calling// resolved 描述 当调用一个 async 函数时，会返回一个 Promise 对象，可以使用then方法添加回调函数。 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值；当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。 当 async 函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 12345678910111213141516171819202122232425// then写法function readFile(a)&#123; return new Promise(resolve=&gt;&#123; setTimeout(()=&gt;&#123; console.log(a); resolve(a); &#125;,500) &#125;)&#125;readFile('a').then(()=&gt;&#123; console.log('b')&#125;).then(()=&gt;&#123; console.log('c')&#125;); //a b c// async写法async function test()&#123; await readFile('a'); console.log('b'); console.log('c');&#125;test(); //a b c 注意：await 关键字仅仅在 async function中有效，并且await只会影响async函数内部的执行顺序。如果在 async function函数体外使用 await ，你只会得到一个语法错误（SyntaxError）。 实现原理 理解async原理之前先了解Generator函数，其实async是Generator的语法糖，async 就等于Generator+自动执行器。 Generator函数 Generator是 ES6 提供的一种异步编程解决方案，返回一个遍历器对象。它与普通函数的区别是： function关键字与函数名之间有一个星号； 函数体内部使用yield语句，定义不同的内部状态。 12345678function* g() &#123; yield 'a'; yield 'b'; yield 'c'; return 'ending';&#125;g(); //返回一个对象 上面例子g()不会执行，而是会返回一个迭代器对象（Iterator Object）。 12var gen = g();gen.next(); // 返回Object &#123;value: "a", done: false&#125; 该对象有一个next方法，调用该方法时会进行分段执行。 gen.next()返回一个对象{value: “a”, done: false}，'a’就是g函数执行到第一个yield语句之后得到的值，false表示g函数还没有执行完，只是在这暂停。以此类推，当执行到第四个next()时，返回{value: “ending”, done: true}，这样，整个g函数就运行完毕了。 综上：调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 yield 表达式 由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。 Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。 123456789function* f() &#123; console.log('执行了！')&#125;var generator = f();setTimeout(function () &#123; generator.next()&#125;, 2000); 上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个 Generator 函数，就变成只有调用next方法时，函数f才会执行。 注意：yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。 现在回过头再来看，将开头那段代码改成Generator函数 1234567891011121314151617function readFile(a)&#123; return new Promise(resolve=&gt;&#123; setTimeout(()=&gt;&#123; console.log(a); resolve(a); &#125;,500) &#125;)&#125;function *foo()&#123; var result = yield readFile('a'); console.log('b');&#125;var it = foo();var result = it.next(); //next返回的value是readFile函数返回的Promise对象result.value.then(()=&gt;&#123; //给Promise对象增加成功的回调 it.next(); //当Promise成功后恢复foo()函数执行&#125;); //a b 使用Generator函数执行时，每次都需要next()来执行，可以看出控制foo函数的暂停和继续却需要写额外的代码，如何控制Generator函数自动执行next() 方法？针对上面代码可以用递归来实现。 1234567891011121314151617181920212223242526function run(g)&#123; var res = g.next(); //res.value是个promise对象 if(!res.done)&#123; res.value.then(()=&gt;&#123; //promise解决了才调用next()继续执行生成器内部函数 run(g); &#125;) &#125;&#125;// testfunction readFile(a)&#123; return new Promise(resolve=&gt;&#123; setTimeout(()=&gt;&#123; console.log(a); resolve(a); &#125;,500) &#125;)&#125;function *foo()&#123; console.log('a'); var result = yield readFile('b'); console.log('c');&#125;run(foo());console.log('d');foo() 运行结果为a d b c。分析：在js运行中，第一次执行foo().next()会打印出a，然后生成器内函数暂停，因为readFile返回一个promise对象并且进入setTimeout进行异步执行，此时进入异步队列等待执行，主线程继续运行，再打出d，等定时器到了，异步队列依次执行，打出b等到结果后，再执行yield后面的代码，打出c。再看async写法： 123456// async写法async function foo() &#123; console.log('a'); var result = await readFile('b'); console.log('c');&#125; 可以看出async函数写法，Generator函数函数很相近，上面代码只是简单模拟async的原理，async可以看成Generator+自动执行器的语法糖。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔥基于taro + dva + typescript 开发的音乐播放器小程序]]></title>
    <url>%2F2019%2F01%2F11%2Ftaro-music%2F</url>
    <content type="text"><![CDATA[简介 本项目是基于 Taro + Dva + TypeScript 开发的音乐播放器小程序，是个人用于学习taro框架开发的，功能也相对简单，当然也存在一些不足，前期是用taro的redux版本开发，后面发现业务代码和页面耦合度高，就加入了dva，一个基于 redux 和 redux-saga 的数据流方案，这里只用了dva的一个核心 dva-core，用于model层来降低耦合，用 dva-model-extend 复用 model，大大提升了开发体验，效果不错。后台是网易云音乐NeteaseCloudMusicApi 提供的API，目前该项目还没有正式上线到小程序。 Usage 本项目已经使用了线上api接口，所以无需运行后台也可以获取数据，当然你也可以在本地运行 NeteaseCloudMusicApi 项目，开启获取歌曲服务，默认端口是3000 123$ git clone git@github.com:Binaryify/NeteaseCloudMusicApi.git$ cd NeteaseCloudMusicApi &amp;&amp; npm install$ npm start 在运行本项目前，确保系统已经全局安装了taro，安装可详见这里，安装完运行项目后使用 微信开发者工具 导入项目（本项目根目录进行导入），开发前注意事项可查看: https://nervjs.github.io/taro/docs/before-dev-remind.html 12345678910# git clone$ git clone https://github.com/huangzhuangjia/taro-music.git# install$ npm i# or yarn install$ yarn install# development$ npm run dev:weapp# production$ npm run build:weapp 项目地址：https://github.com/huangzhuangjia/taro-music]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化总结]]></title>
    <url>%2F2018%2F03%2F14%2Fperformance-optimization%2F</url>
    <content type="text"><![CDATA[优化的原则和方向 前端性能优化的原则其实就是更好的用户体验，具体实现的目标大体有两个： 合理使用内存或缓存，减少请求； 减少CPU或者GPU的计算，达到更快的展现。 前端在性能优化的方向大体有两个： 减少页面体积，提升网络加载 优化页面渲染 详情 减少页面体积，提升网络加载 1、静态资源的压缩合并（JS 代码压缩合并、CSS 代码压缩合并、雪碧图） 压缩是为了减小文件体积，减轻网络负载，达到更快的下载； 合并和雪碧图都是为了减少文件的请求次数，但不是合并的就一个比没有合并时加载快，要看合并之后的体积，若文件合并后太大了也不太利于性能优化，所以在实际的项目中要做好权衡。 2、静态资源缓存（资源名称加 MD5 戳） 可以通过链接名称控制缓存：通过前端构建工具为打包的文件添加md5后缀，这样当打包上线时请求的链接发生改变，这样可以防止由于缓导致静态资源更新失效； 3、 使用 CDN 让资源加载更快 优化页面渲染 1、CSS 放前面，JS 放后面 浏览器在渲染解析过程中，若遇到&lt;link href=&quot;...&quot;&gt;和&lt;script src=&quot;...&quot;&gt;这种外链加载 CSS 和 JS 的标签，浏览器会异步下载并解析执行。CSS放在头部是为了让浏览器尽早解析执行Css文件，渲染出页面的样式，若放在底部会出现渲染卡顿的情况，影响性能和体验。 而当渲染过程中遇到script标签时就会执行JS代码，从阻塞页面渲染，因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。所以要将JS放在底部，等到页面渲染完成之后再去解析执行js，保证用户体验性。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。 另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。 2、懒加载（图片懒加载、下拉加载更多） 先将src赋值成一个通用的预览图，下拉时候再动态赋值成正式的图片。如下，preview.png是预览图片，比较小，加载很快，而且很多图片都共用这个preview.png，加载一次即可。待页面下拉，图片显示出来时，再去替换src为data-src的值。（data-开头的属性浏览器渲染的时候会忽略掉，提高渲染性能） 1&lt;img src="preview.png" data-src="realImg.png"/&gt; 3、减少DOM 查询，对 DOM 查询做缓存 1234567// 只查询一个 DOM ，缓存在 pList 中了var pList = document.getElementsByTagName('p') for (var i = 0; i &lt; pList.length; i++) &#123;&#125;// 每次循环，都会查询 DOM ，耗费性能for (var i = 0; i &lt; document.getElementsByTagName('p').length; i++) &#123;&#125; 4、减少DOM 操作，多个操作尽量合并在一起执行（DocumentFragment） DOM 操作是非常耗费性能的，因此插入多个标签时，先插入 Fragment 然后再统一插入 DOM。因为Fragment文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流。 12345678910var listNode = document.getElementById('list')// 要插入 10 个 li 标签var frag = document.createDocumentFragment();var i, li;for(i = 0; i &lt; 10; i++) &#123; li = document.createElement("li"); li.innerHTML = "List item " + i; frag.appendChild(li); //先放在 frag 中，最后一次性插入到 DOM 结构中。&#125;listNode.appendChild(frag); 5、事件节流 在开发过程中会遇到页面一些频繁触发的事件，比如mouseover、scroll、resize等事件。一秒可以执行很多次，这样会造成严重的页面性能问题，导致页面c出现卡顿甚至浏览器崩溃。因此我们需要对事件进行节流，简单的说就是控制其执行的次数。这里就涉及到了常用到的js的节流和防抖功能实现。 1、 防抖（debounce）：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 1234567891011121314151617function debounce(fn, delay) &#123; // 定时器，用来 setTimeout var timer // 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 fn 函数 return function () &#123; // 保存函数调用时的上下文和参数，传递给 fn var context = this var args = arguments // 每次这个返回的函数被调用，就清除定时器，以保证不执行 fn timer &amp;&amp; clearTimeout(timer) // 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作）， // 再过 delay 毫秒就执行 fn timer = setTimeout(function () &#123; fn.apply(context, args) &#125;, delay) &#125;&#125; 2、节流（throttle）：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。 123456789101112131415161718192021222324252627282930function throttle(fn, threshhold) &#123; // 记录上次执行的时间 var last // 定时器 var timer // 默认间隔为 250ms threshhold || (threshhold = 250) // 返回的函数，每过 threshhold 毫秒就执行一次 fn 函数 return function () &#123; // 保存函数调用时的上下文和参数，传递给 fn var context = this var args = arguments var now = +new Date() // 如果距离上次执行 fn 函数的时间小于 threshhold，那么就放弃 // 执行 fn，并重新计时 if (last &amp;&amp; now &lt; last + threshhold) &#123; timer &amp;&amp; clearTimeout(timer) // 保证在当前时间区间结束后，再执行一次 fn timer = setTimeout(function () &#123; last = now fn.apply(context, args) &#125;, threshhold) // 在时间区间的最开始和到达指定间隔的时候执行一次 fn &#125; else &#123; last = now fn.apply(context, args) &#125; &#125;&#125; 6、尽早执行操作（DOMContentLoaded） 123456789window.addEventListener('load', function () &#123; // 页面的全部资源加载完才会执行，包括图片、视频等&#125;)document.addEventListener('DOMContentLoaded', function () &#123; // DOM 渲染完即可执行，此时图片、视频还可能没有加载完&#125;)$(document).ready(&#123;function () &#123; // 同DOMContentLoaded&#125;) 7、使用 预渲染 或者 SSR后端渲染，数据直接输出到 HTML 中，减少浏览器使用 JS 模板渲染页面 HTML 的时间 (如Vue SSR)，同时也有利于网站的SEO。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Vue响应式原理]]></title>
    <url>%2F2018%2F02%2F07%2FAbout-responsive-of-Vue%2F</url>
    <content type="text"><![CDATA[初步 最近一段时间在阅读Vue源码，从它的核心原理入手，开始了源码的学习，而其核心原理就是其数据的响应式，讲到Vue的响应式原理，我们可以从它的兼容性说起，Vue不支持IE8以下版本的浏览器，因为Vue是基于 Object.defineProperty 来实现数据响应的，而 Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因；Vue通过Object.defineProperty的 getter/setter 对收集的依赖项进行监听,在属性被访问和修改时通知变化,进而更新视图数据； 受现代JavaScript 的限制 (以及废弃 Object.observe)，Vue不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让Vue转换它，这样才能让它是响应的。 我们这里是根据Vue2.3源码进行分析,Vue数据响应式变化主要涉及 Observer, Watcher , Dep 这三个主要的类；因此要弄清Vue响应式变化需要明白这个三个类之间是如何运作联系的；以及它们的原理，负责的逻辑操作。那么我们从一个简单的Vue实例的代码来分析Vue的响应式原理 123456789101112131415var vue = new Vue(&#123; el: "#app", data: &#123; name: 'Junga' &#125;, created () &#123; this.helloWorld() &#125;, methods: &#123; helloWorld: function() &#123; console.log('my name is' + this.name) &#125; &#125; ...&#125;) Vue初始化实例 根据Vue的生命周期我们知道，Vue首先会进行init初始化操作；源码在src/core/instance/init.js中 1234567891011121314/*初始化生命周期*/initLifecycle(vm)/*初始化事件*/initEvents(vm)Object.defineProperty /*初始化render*/initRender(vm)/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/callHook(vm, 'beforeCreate')initInjections(vm) // resolve injections before data/props/*初始化props、methods、data、computed与watch*/initState(vm)initProvide(vm) // resolve provide after data/props/*调用created钩子函数并且触发created钩子事件*/callHook(vm, 'created') 以上代码可以看到 initState(vm) 是用来初始化props,methods,data,computed和watch; src/core/instance/state.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*初始化props、methods、data、computed与watch*/export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options /*初始化props*/ if (opts.props) initProps(vm, opts.props) /*初始化方法*/ if (opts.methods) initMethods(vm, opts.methods) /*初始化data*/ if (opts.data) &#123; initData(vm) &#125; else &#123; /*该组件没有data的时候绑定一个空对象*/ observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; /*初始化computed*/ if (opts.computed) initComputed(vm, opts.computed) /*初始化watchers*/ if (opts.watch) initWatch(vm, opts.watch)&#125;.../*初始化data*/function initData (vm: Component) &#123; /*得到data数据*/ let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125;defi ... //遍历data中的数据 while (i--) &#123; /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/ if (props &amp;&amp; hasOwn(props, keys[i])) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property "$&#123;keys[i]&#125;" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(keys[i])) &#123; /*判断是否是保留字段*/ /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/ proxy(vm, `_data`, keys[i]) &#125; &#125; // observe data /*这里通过observe实例化Observe对象，开始对数据进行绑定，asRootData用来根数据，用来计算实例化根数据的个数，下面会进行递归observe进行对深层对象的绑定。则asRootData为非true*/ observe(data, true /* asRootData */)&#125; 1、initData 现在我们重点分析下initData，这里主要做了两件事，一是将_data上面的数据代理到vm上，二是通过执行 *observe(data, true / asRootData */)**将所有data变成可观察的，即对data定义的每个属性进行getter/setter操作，这里就是Vue实现响应式的基础；observe的实现如下 src/core/observer/index.js 1234567891011121314151617181920212223242526 /*尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。*/export function observe (value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value)) &#123; return &#125; let ob: Observer | void /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例，这里可以看Observer实例化的代码def(value, '__ob__', this)*/ if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。而且该对象在shouldConvert的时候才会进行Observer。这是一个标识位，避免重复对value进行Observer */ observerState.shouldConvert &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/ ob.vmCount++ &#125; return ob&#125; 这里 new Observer(value) 就是实现响应式的核心方法之一了，通过它将data转变可以成观察的，而这里正是我们开头说的，用了 Object.defineProperty 实现了data的 getter/setter 操作，通过 Watcher 来观察数据的变化，进而更新到视图中。 2、Observer Observer类是将每个目标对象（即data）的键值转换成getter/setter形式，用于进行依赖收集以及调度更新。 src/core/observer/index.js 123456789101112131415161718192021222324252627282930313233export class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that has this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 /* 将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考/src/core/util/lang.js*/ def(value, '__ob__', this) if (Array.isArray(value)) &#123; /*如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。*/ const augment = hasProto ? protoAugment /*直接覆盖原型的方法来修改目标对象*/ : copyAugment /*定义（覆盖）目标对象或数组的某一个方法*/ augment(value, arrayMethods, arrayKeys) /*如果是数组则需要遍历数组的每一个成员进行observe*/ this.observeArray(value) &#125; else &#123; /*如果是对象则直接walk进行绑定*/ this.walk(value) &#125;, walk (obj: Object) &#123; const keys = Object.keys(obj) /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/ for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i], obj[keys[i]]) &#125; &#125; &#125; 首先将Observer实例绑定到data的__ob__属性上面去，防止重复绑定； 若data为数组，先实现对应的变异方法（这里变异方法是指Vue重写了数组的7种原生方法，这里不做赘述，后续再说明），再将数组的每个成员进行observe，使之成响应式数据； 否则执行walk()方法，遍历data所有的数据，进行getter/setter绑定，这里的核心方法就是 defineReative(obj, keys[i], obj[keys[i]]) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364export function defineReactive ( obj: Object, key: string, val: any, customSetter?: Function) &#123; /*在闭包中定义一个dep对象*/ const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/ // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set /*对象的子对象递归进行observe并返回子节点的Observer对象*/ let childOb = observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; /*如果原本对象拥有getter方法则执行*/ const value = getter ? getter.call(obj) : val if (Dep.target) &#123; /*进行依赖收集*/ dep.depend() if (childOb) &#123; /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/ childOb.dep.depend() &#125; if (Array.isArray(value)) &#123; /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/ dependArray(value) &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/ const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) &#123; customSetter() &#125; if (setter) &#123; /*如果原本对象拥有setter方法则执行setter*/ setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; /*新的值需要重新进行observe，保证数据响应式*/ childOb = observe(newVal) /*dep对象通知所有的观察者*/ dep.notify() &#125; &#125;)&#125; 其中getter方法： 先为每个data声明一个 Dep 实例对象，被用于getter时执行dep.depend()进行收集相关的依赖; 根据Dep.target来判断是否收集依赖，还是普通取值。Dep.target是在什么时候，如何收集的后面再说明，先简单了解它的作用， 那么问题来了，我们为啥要收集相关依赖呢？ 123456789101112new Vue(&#123; template: `&lt;div&gt; &lt;span&gt;text1:&lt;/span&gt; &#123;&#123;text1&#125;&#125; &lt;span&gt;text2:&lt;/span&gt; &#123;&#123;text2&#125;&#125; &lt;div&gt;`, data: &#123; text1: 'text1', text2: 'text2', text3: 'text3' &#125;&#125;); 我们可以从以上代码看出，data中text3并没有被模板实际用到，为了提高代码执行效率，我们没有必要对其进行响应式处理，因此，依赖收集简单点理解就是收集只在实际页面中用到的data数据，然后打上标记，这里就是标记为Dep.target。 在setter方法中: 获取新的值并且进行observe，保证数据响应式； 通过dep对象通知所有观察者去更新数据，从而达到响应式效果。 在Observer类中，我们可以看到在getter时，dep会收集相关依赖，即收集依赖的watcher，然后在setter操作时候通过dep去通知watcher,此时watcher就执行变化，其实我们可以简单理解：Dep可以看做是书店，Watcher就是书店订阅者，而Observer就是书店的书，订阅者在书店订阅书籍，就可以添加订阅者信息，一旦有新书就会通过书店给订阅者发送消息。 3、Watcher Watcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Dep的subs中，数据变动的时候Dep会通知Watcher实例，然后由Watcher实例回调cb进行视图的更新。 src/core/observer/watcher.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204export default class Watcher &#123; constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: Object ) &#123; this.vm = vm /*_watchers存放订阅者实例*/ vm._watchers.push(this) // options if (options) &#123; this.deep = !!options.deep this.user = !!options.user this.lazy = !!options.lazy this.sync = !!options.sync &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false &#125; this.cb = cb this.id = ++uid // uid for batching this.active = true this.dirty = this.lazy // for lazy watchers this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '' // parse expression for getter /*把表达式expOrFn解析成getter*/ if (typeof expOrFn === 'function') &#123; this.getter = expOrFn &#125; else &#123; this.getter = parsePath(expOrFn) if (!this.getter) &#123; this.getter = function () &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed watching path: "$&#123;expOrFn&#125;" ` + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm ) &#125; &#125; this.value = this.lazy ? undefined : this.get() &#125; /** * Evaluate the getter, and re-collect dependencies. */ /*获得getter的值并且重新进行依赖收集*/ get () &#123; /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/ pushTarget(this) let value const vm = this.vm /*执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。 在将Dep.target设置为自生观察者实例以后，执行getter操作。 譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c， 那么在执行getter的时候就会触发a跟c两个数据的getter函数， 在getter函数中即可判断Dep.target是否存在然后完成依赖收集， 将该观察者对象放入闭包中的Dep的subs中去。*/ if (this.user) &#123; try &#123; value = this.getter.call(vm, vm) &#125; catch (e) &#123; handleError(e, vm, `getter for watcher "$&#123;this.expression&#125;"`) &#125; &#125; else &#123; value = this.getter.call(vm, vm) &#125; // "touch" every property so they are all tracked as // dependencies for deep watching /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/ if (this.deep) &#123; /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/ traverse(value) &#125; /*将观察者实例从target栈中取出并设置给Dep.target*/ popTarget() this.cleanupDeps() return value &#125; /** * Add a dependency to this directive. */ /*添加一个依赖关系到Deps集合中*/ addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125; &#125; /** * Clean up for dependency collection. */ /*清理依赖收集*/ cleanupDeps () &#123; /*移除所有观察者对象*/ ... &#125; /** * Subscriber interface. * Will be called when a dependency changes. */ /* 调度者接口，当依赖发生改变的时候进行回调。 */ update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; /*同步则执行run直接渲染视图*/ this.run() &#125; else &#123; /*异步推送到观察者队列中，下一个tick时调用。*/ queueWatcher(this) &#125; &#125; /** * Scheduler job interface. * Will be called by the scheduler. */ /* 调度者工作接口，将被调度者回调。 */ run () &#123; if (this.active) &#123; /* get操作在获取value本身也会执行getter从而调用update更新视图 */ const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. /* 即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。 */ isObject(value) || this.deep ) &#123; // set new value const oldValue = this.value /*设置新的值*/ this.value = value /*触发回调*/ if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue) &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher "$&#123;this.expression&#125;"`) &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue) &#125; &#125; &#125; &#125; /** * Evaluate the value of the watcher. * This only gets called for lazy watchers. */ /*获取观察者的值*/ evaluate () &#123; this.value = this.get() this.dirty = false &#125; /** * Depend on all deps collected by this watcher. */ /*收集该watcher的所有deps依赖*/ depend () &#123; let i = this.deps.length while (i--) &#123; this.deps[i].depend() &#125; &#125; /** * Remove self from all dependencies' subscriber list. */ /*将自身从所有依赖收集订阅列表删除*/ teardown () &#123; ... &#125;&#125; 4、Dep 被Observer的data在触发 getter 时，Dep 就会收集依赖的 Watcher ，其实 Dep 就像刚才说的是一个书店，可以接受多个订阅者的订阅，当有新书时即在data变动时，就会通过 Dep 给 Watcher 发通知进行更新。 src/core/observer/dep.js 123456789101112131415161718192021222324252627282930313233343536export default class Dep &#123; static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () &#123; this.id = uid++ this.subs = [] &#125; /*添加一个观察者对象*/ addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; /*移除一个观察者对象*/ removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; /*依赖收集，当存在Dep.target的时候添加观察者对象*/ depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; /*通知所有订阅者*/ notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 总结 其实在 Vue 中初始化渲染时，视图上绑定的数据就会实例化一个 Watcher，依赖收集就是是通过属性的 getter 函数完成的，文章一开始讲到的 Observer 、Watcher 、Dep 都与依赖收集相关。其中 Observer 与 Dep 是一对一的关系， Dep 与 Watcher 是多对多的关系，Dep 则是 Observer 和 Watcher 之间的纽带。依赖收集完成后，当属性变化会执行被 Observer 对象的 dep.notify() 方法，这个方法会遍历订阅者（Watcher）列表向其发送消息， Watcher 会执行 run 方法去更新视图，我们再来看一张图总结一下： 在 Vue 中模板编译过程中的指令或者数据绑定都会实例化一个 Watcher 实例，实例化过程中会触发 get() 将自身指向 Dep.target; data在 Observer 时执行 getter 会触发 dep.depend() 进行依赖收集;依赖收集的结果：1、data在 Observer 时闭包的dep实例的subs添加观察它的 Watcher 实例；2. Watcher 的deps中添加观察对象 Observer 时的闭包dep； 当data中被 Observer 的某个对象值变化后，触发subs中观察它的watcher执行 update() 方法，最后实际上是调用watcher的回调函数cb，进而更新视图。 参考 Vue源码 Vue文档 Vue源码学习]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于移动端开发中遇到的坑]]></title>
    <url>%2F2017%2F07%2F30%2Fsomething-about-web-app%2F</url>
    <content type="text"><![CDATA[前言 三月中旬跳完槽之后就好好久没写博客了，跳到某公司之后，怀揣着满腔热水的我又投入了工作中，从面试、办理离职到入职只用了一个星期。这效率也没谁了，入职之后给了一个小项目，用Vue全家桶开发一个简易的个人博客。因为之前自学了解过，于是很快就上手，原本要求用两周的时间用了三天就完成了全部的功能，于是就一周之后就开始安排到项目组进行实际的开发中了，最后被安排到招聘组负责校招的前端开发。一去就搞事情，给我安排了后台移动端的开发，就是为了方便领导手机上使用，基于内部项目都是用了Vue，最后确定用Vue+一个移动端的基于Vue的UI框架Vux进行开发，于是就进入了移动端的踩坑之旅，之前比较少接触移动端开发。 项目开发是基于Vue的UI框架Vux，其实就是一套基于We-UI的一套移动端UI框架，但根据实际情况，一些布局还是得自己去重构。于是就愉快的踩起了移动端开发的坑。 滚动穿透问题 滚动穿透是指在移动端当有 fixed 遮罩背景和弹出层时，在屏幕上滑动能够滑动背景下面的内容。网上整理了解决方案，但有些还是存在一定的问题： 设置overflow为hidden 123456.modal-open &#123; &amp;, body &#123; overflow: hidden; height: 100% &#125;&#125; 即当弹出层弹出时在html上添加.modal-open,禁用 html 和 body 的滚动条,但实际用上就会发现： 由于 html 和 body的滚动条都被禁用，弹出层后页面的滚动位置会丢失，需要用 js 来计算原来滚动的位置，在弹出时保持滚动位置； 杯具的是页面的背景还是能够有滚的动的效果 js 之 touchmove + preventDefault 123modal.addEventListener('touchmove', function(e) &#123; e.preventDefault();&#125;, false); 即通过阻止移动端touchmove事件，但实际用上会发现弹出层需要滚动时也会被阻止 最后解决方案：position: fixed 1234body.modal-open &#123; position: fixed; width: 100%;&#125; 这种方式同样当弹出层弹出时滚动条会丢失，所以还需要使用js来保存滚动条的位置，在关闭弹出层时将滚动位置还原； 1234567891011121314var ModalHelper = (function(bodyCls) &#123; var scrollTop; // 在闭包中定义一个用来保存滚动位置的变量 return &#123; afterOpen: function() &#123; //弹出之后记录保存滚动位置，并且给body添加.modal-open scrollTop = document.scrollingElement.scrollTop; document.body.classList.add(bodyCls); document.body.style.top = -scrollTop + 'px'; &#125;, beforeClose: function() &#123; //关闭时将.modal-open移除并还原之前保存滚动位置 document.body.classList.remove(bodyCls); document.scrollingElement.scrollTop = scrollTop; &#125; &#125;;&#125;)('modal-open'); 本人亲测确实比较完美解决了移动端滚动问题😊 移动端输入框被键盘挡住问题 由于所开发的页面内嵌在公司的一个APP中，有一个类似聊天窗口的界面，测试的时候发现在部分安卓机中输入框被完全遮挡住，踩这个坑时在网上找了好多资料，好像都没有一套完整的解决办法，先看其中一种解决办法，可以解决绝大数安卓机上面的问题： 1234567if(/Android/.test(navigator.appVersion)) &#123; window.addEventListener("resize", function() &#123; if(document.activeElement.tagName=="INPUT" || document.activeElement.tagName=="TEXTAREA") &#123; document.activeElement.scrollIntoView(); &#125; &#125;)&#125; 即在安卓机中通过监听当窗口resize时，判断当前获得焦点的元素是否为输入框，再调用该元素的scrollIntoView()，即将该元素展示在当前窗口的可视区域。由于只有scrollIntoView被各浏览器均支持，所以这个方法最为常用。 使用这段代码之后，在微信或者其他浏览器测试时有效果，但因为是需要内嵌在自家APP上，使用这段代码一直没有解决输入框被挡住的问题，最后测试才发现，APP内置浏览器在聚焦输入框弹出键盘根本没有触发窗口的resize事件，瞬间心中万马奔腾~~~，后面在借鉴了某阿里的一个网页版的聊天界面，发现它是通过获取输入框焦点将输入框定位到窗口略高于输入框的位置，在失去焦点键盘弹回时再恢复到底部，于是通过这种方式处理，暂时比较暴力的解决了在安卓上该APP上输入框被挡住的问题，这种方法显然是不完美的，比如由于无法监听resize事件，而且使用的键盘高度不固定，所以只能大概的将高度设置保持在屏幕一半偏上一点。保证绝大数情况下输入框在键盘之上显示。 IOS滚动不平滑的问题 在移动端特别是iOS中，当滚动屏幕时会发现手指一拿开滚动就停止，这种用户体验效果很不好，有种给用户滚动卡顿的感觉。CSS3中的-webkit-overflow-scrolling属性可以完美的解决这个问题，该属性可控制元素在移动设备上是否使用滚动回弹效果: auto 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。 touch 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>移动端web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域与闭包的一二事]]></title>
    <url>%2F2017%2F03%2F05%2Fscope-and-closure%2F</url>
    <content type="text"><![CDATA[闭包是JavaScript语言的一大特点，可以说再开发的过程中，它无处不在，即使有时候我们都没有发现它的存在。接触JavaScript以来，虽然说是一直有对闭包了解，但是实际应用起来或者分析一些代码的时候却有些吃力。现在回过头总结，才又进一步的揭开了闭包的一层面纱。而在讲闭包之前，我们要先明白JavaScript中又一个重要的知识，那就是JavaScript的内存机制以及作用域，这两个是我们有效理解闭包原理的前提吧。前面我们已经讲了JavaScript的内存机制，那么在这里先理解什么是作用域和作用域链。 作用域与作用域链 之前我们已经了解了JavaScript内存以及垃圾回收的机制了，在讲作用域之前，其实还有一个知识点，那就是JavaScript的执行环境产生的变量对象。 变量对象 执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。而每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但是解析器在处理数据时会在后台处理它们。 JavaScript的运行环境大概有三种： 全局环境：全局环境是最外围的一个执行环境。在web浏览器中，全局执行环境被认为是window对象，因此所有的全局变量和函数都会作为window对象的属性和方法创建的； 局部环境：通常是函数内部创建的执行环境。 eval 变量对象的创建过程： 创建arguments对象。检查当前执行环境中的参数，建立该对象下的属性与属性值。 检查当前执行环境中的函数声明，即function关键字的函数声明，在变量对象中以函数名建立一个属性，其值是指向该函数所在内存地址的引用。若函数名已经存在，则改属性将会被新的引用说覆盖。 检查当前执行环境中的变量声明，在变量对象以变量名建立一个属性，并初始化为undefined。 我们经常说到的变量提升，函数优先提升就是这样一个过程，在每个执行环境中的变量对象被创建的时候都会经历这几个步骤。 而当某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的变量和函数定义也随之销毁，全局执行环境直到应用程序退出比如浏览器关闭时才会销毁。 作用域 了解了变量对象之后，我们在这里给作用域一个定义，作用域就是用来管理JavaScript引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称（这里指的是变量名和函数名）进行变量查找的一套规则。说的简单点就是作用域就是变量与函数的可访问范围，它控制着变量与函数的可见性与生命周期。 JavaScript代码的整个执行过程分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器执行完成，将代码编译成可执行代码，并确立作用域的规则。执行阶段由引擎完成，主要是执行可执行代码，执行上下文在这个阶段创建。 我们举一个简单粗暴的🌰解释一下引擎、编译器和作用域是如何协同工作的就明白了： 1var a = 10; JavaScript执行上面代码的时候会将其看成是两个声明，一个是编译阶段的定义声明，一个是引擎执行阶段的赋值声明，所以我们可以分解成： 12var a;a=10; 编译阶段：“编译器&quot;会询问&quot;作用域”：当前的作用域中是否已经有变量a，如果有，那么&quot;编译器&quot;会忽略这个声明，继续进行编译；如果没有，那么它会要求“作用域”在当前的作用域声明一个新的变量，并命名为a; 执行阶段：“引擎&quot;处理a = 10时，首先会询问&quot;作用域”：当前的作用域中是否存在一个a的变量，如果存在，那么引擎就会使用这个变量，如果否，那么&quot;引擎&quot;会继续查找该变量。如果&quot;引擎&quot;最终找到了a变量，那么就将10赋值给它，否则&quot;引擎&quot;就会抛出一个异常。 总结一下变量赋值操作过程，即：首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时，引擎会在作用域中查找该变量，如果能够找到就对它赋值，否则就抛出异常。 编译阶段是在当前的作用域中声明变量，而引擎查找时，是在整个作用域中查找该变量。 作用域链 上面我们讲了，引擎在查找变量的时候，是在整个作用域中查找的，在当前作用域中找不到它会继续往上一层作用域中查找，直至到顶层作用域即全局作用域。而这一个过程中就产生了我们所说的作用域链，作用域链是在执行上下文创建的时候产生的。 我们说作用域是JavaScript编译执行的一套规则，那么作用域链就是这个规则的一种具体体现。 作用域链是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终是当前执行的代码所在环境的变量对象。而前面我们已经讲了变量对象的创建过程。作用域链的下一个变量对象来自包含环境即外部环境，这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。 闭包 定义 理解了作用域与作用域链之后，我们再来看看闭包的一些定义： MDN 对闭包的定义： 闭包是指那些能够访问独立（自由）变量的函数（变量在本地使用，但定义在一个封闭的作用域中）。换句话说，这些函数可以「记忆」它被创建时候的环境。 《JavaScript 权威指南(第6版)》对闭包的定义： 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为闭包。 《JavaScript 高级程序设计(第3版)》对闭包的定义： 闭包是指有权访问另一个函数作用域中的变量的函数。 最后是阮一峰老师对闭包的解释： 由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成定义在一个函数内部的函数。 从以上定义我们可以总结，我们可以简单理解就是一个函数被一个外部函数所包含，根据上面我们讲到的作用域链只是我们可以知道，当前被包含的函数内部（即当前的执行环境）是有权访问它外部函数（外部的执行环境）的变量对象的，那么这个函数就是我们所说的闭包了。原来对闭包的理解就是这么的通畅，哈哈😆。 闭包的用途 我们都知道，当函数执行完毕的时候，局部的活动对象就会退出执行栈，随后就会被销毁，但是闭包则不是酱紫的。废话不多说，我们再来看一个🌰（图画的有点丑，将就着看吧哈哈） 12345678910function fun()&#123; var name = "Junga" function fun1()&#123; var greet = 'Hello '+ name; console.log(greet); &#125; return fun1;&#125;var result = fun();result(); 上图展示的是调用函数fun()的过程中产生的作用域链之间的关系。作用域链本质上就是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。上面代码很明显，fun1()就是一个闭包，因为它的作用域链包含了外部函数fun()的活动对象，那为什么闭包在运行完之后不会被销毁呢？下面解释一下： 在函数fun()中，返回了内部函数fun1()，它的作用域链被初始化为包含fun()函数的活动对象和全局变量对象。因此，fun1()就可以访问fun()中定义的所有变量。接下来最重要的一点就是，fun()函数在执行完毕之后其活动对象也不会被销毁，因为闭包fun1()的作用域链仍然在引用这个活动对象。换句话说，当fun()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中，直到闭包fun1()被销毁后，fun()的活动对象才会被销毁。例如当上面的result被赋值为null时，此时闭包fun1()就被解除了引用，随后被垃圾收集器回收，最后释放其内存。 因此，可以总结出闭包有两大用途：1、可以读取函数内部的变量；2、可以让函数内部的变量始终保存在内存中。 注意：由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存，过度使用闭包可能会导致内存泄漏。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flexbox学习小记]]></title>
    <url>%2F2017%2F02%2F23%2Fflexbox%2F</url>
    <content type="text"><![CDATA[因为现在的公司要求布局的兼容性要兼容到至少IE7，所以对于flexbox这种布局也没有了解太多，之前有听说过flex布局，听起来是一种比较高大上，可以自适应不同尺寸屏幕的布局方式，但是没有正式的去学习了解。flexbox是CSS3算是比较新的一个特性，最近刚好有时间也有兴趣就了解了，觉得还是要做一下总结，不然很快又忘了😰。 flexbox布局意为弹性布局，是css3的弹性盒子模式，用它可以告别float布局，也可以简单实现垂直居中，并且具有响应式，就是可以自动调整，计算元素在容器空间中的大小，可以说：完美~~~（此处应有标志性动作) Flex布局背后的主要思想是给容器控制项目（Flex项目）的宽度、高度的能力，使用Flex项目可以自动填满容器的可用空间（主要是适应所有类型的显示设备和屏幕大小）。Flex容器使用Flex项目可以自动放大与收缩，用来填补可用的空闲空间。 先看下flexbox布局对各大浏览器的支持情况，基本也就告别低版本的浏览器了： 下面我们来简单了解一下flex布局的基本概念： flex项目排列方式： main axis:Flex容器的主轴主要用来配置Flex项目。注意，它不一定是水平，这主要取决于flex-direction属性。 main-start | main-end:Flex项目的配置从容器的主轴起点边开始，往主轴终点边结束。 main size:Flex项目的在主轴方向的宽度或高度就是项目的主轴长度，Flex项目的主轴长度属性是width或height属性，由哪一个对着主轴方向决定。 cross axis:与主轴垂直的轴称作侧轴，是侧轴方向的延伸。 cross-start | cross-end:伸缩行的配置从容器的侧轴起点边开始，往侧轴终点边结束。 cross size:Flex项目的在侧轴方向的宽度或高度就是项目的侧轴长度，Flex项目的侧轴长度属性是width或height属性，由哪一个对着侧轴方向决定。 flex布局拥有的属性： 父容器的属性 display:flex | inline-flex。 表明这个容器是flex布局。flex是块伸缩容器，inline-flex是内联伸缩容器。 flex-direction: row | row-reverse | column | column-reverse; 表明容器里面的子元素的排列方向。 flex-wrap: nowrap | wrap | wrap-reverse; 如果子元素溢出父容器的时候是否进行换行。 justify-content: flex-start | flex-end | center | space-between | space-around; 这一个容器子元素横向排版在容器的哪个位置 align-items: flex-start | flex-end | center | baseline | stretch; 这个容器子元素纵向排版在容器的哪个位置 align-content: flex-start | flex-end | center | space-between | space-around | stretch; 当容器内有多行项目的时候，项目的布局 子元素的属性 order: ; 子元素的排序 flex-grow: ; 分配剩余空间的比例 flex-shrink: ; 分配溢出空间的比例 flex-basis: | auto; flex: none | [ &lt;‘flex-grow’&gt; &lt;‘flex-shrink’&gt;? || &lt;‘flex-basis’&gt; ] 在容器中占比 align-self: auto | flex-start | flex-end | center | baseline | stretch; 特定某个子元素的排布情况 属性详解 Flex容器属性： display属性 display定义了一个Flex容器，为其内容建立新的伸缩格式化上下文。其中flex是块伸缩容器，inline-flex是内联伸缩容器。 123.container&#123; display: flex;/* or inline-flex*/&#125; 如果元素display的值指定为inline-flex，而且元素是一个浮动元素或绝对定位元素，则display的计算值是flex。 flex-direction属性 flex-direction定义了flex容器里面的flex项目的排列方向，水平排列和竖直排列 123.container &#123; flex-direction: row | row-reverse | column | column-reverse; &#125; row(默认值): 主轴为水平方向，从左向右排列 row-reverse: 主轴为水平方向，从右向左排列 column: 主轴为垂直方向，从上到下排列 column-reverse: 主轴为垂直方向，从下向上排列 flex-wrap属性 flex-wrap定义了当一行或者一列排不上，flex项目是否换行，默认是不换行。 123.container &#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap(默认值): 单行显示不换行 wrap: 多行显示换行，第一行在上方 wrap-reverse: 多行显示换行，第一行在下方 flex-flow属性 flex-flow是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。道理就跟border: 1px solid red类似，多个值写在同一行。 justify-content属性 justify-content定义了flex项目在flex容器主轴中的对齐方式。 123container&#123; justify-content: &#123;flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：flex项目在主轴方向上进行左对齐 flex-end：flex项目在主轴方向上进行右对齐 center： flex项目在主轴方向上进行居中 space-between：flex项目两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性 align-items定义了flex项目在flex容器竖轴上的对齐方式。类似justify-content属性，只不过是方向不同。 123container&#123; align-items: &#123;flex-start | flex-end | center | baseline | stretch;&#125; flex-start（默认值）：flex项目在flex容器竖轴方向起点对齐。 flex-end：flex项目在flex容器竖轴方向终点对齐。 center：flex项目在flex容器竖轴方向中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性 align-content属性定义了多根轴线的对齐方式。当伸缩容器的侧轴还有多余空间时，align-content属性可以用来调准伸缩行在伸缩容器里的对齐方式，这与调准伸缩项目在主轴上对齐方式的justify-content属性类似。 123container&#123; align-items: &#123;flex-start | flex-end | center | baseline | stretch;&#125; flex-start：与竖轴方向的起点对齐。 flex-end：与竖轴方向的终点对齐。 center：与竖轴方向的中点对齐。 space-between：与竖轴的两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个竖轴方向。 Flex项目属性： order属性 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;&#125; 根据order重新排序伸缩项目。有最小（负值最大）order的伸缩项目排在第一个。若有多个项目有相同的order值，这些项目照文件顺序排。这个步骤影响了伸缩项目生盒树成的盒子的顺序，也影响了后面的演算法如何处理各项目。 flex-grow属性 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。flex-grow取负值将失效。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如上图所示，若所有flex项目的flex-grow属性都为1，则flex容器中的flex项目尺寸都相等，若其中一个为2其他为1，则为其他flex项目的两倍。 flex-shrink属性 flex-shrink属性则与flex-grow属性相反，定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。与flex-grow一样，flex-shrink取负值将失效。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; flex-basis属性 flex-basis属性定义了Flex项目在分配Flex容器剩余空间之前的一个默认尺寸，通俗一点是说在flex-grow和flex-shrink属性调整它的大小以适应Flex容器之前，可以指定Flex项目的初始大小。它的默认值为auto，即项目的本来大小。flex-basis可以取任何用于width属性的任何值，比如 % || em || rem || px等。 注意：如果flex-basis属性的值是0时，也需要使用单位。即flex-basis: 0px不能写成flex-basis:0。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */ &#125; flex属性 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。 注意：flex-grow第一，然后是flex-shrink，最后是flex-basis。缩写成GSB。 123.item &#123; flex: 0 1 auto;/*flex-grow: 0; flex-shrink: 1; flex-basis: auto;*/&#125; flex常见值: flex: 0 auto,flex: initial与flex: 0 1 auto相同。根据width／height属性决定元素的尺寸。（如果项目的主轴长度属性的计算值为auto，则会根据其内容来决定元素尺寸。）当剩余空间为正值时，伸缩项目无法伸缩，但当空间不足时，伸缩项目可收缩至其最小值。 flex: auto与flex: 1 1 auto相同。根据width／height属性决定元素的尺寸，但是完全可以伸缩，会吸收主轴上剩下的空间。 flex: none与flex: 0 0 auto相同。根据width／height属性决定元素的尺寸，但是完全不可伸缩，基本上就是一个固定宽度的元素，初始宽度是基于flex项目内容大小。注意：即使在空间不够而溢出的情况下，伸缩项目也不能收缩。 flex: 与flex: 1 0px相同。该值使元素可伸缩，并将伸缩基准值设置为零，导致该项目会根据设置的比率占用伸缩容器的剩余空间。如果一个伸缩容器里的所有项目都使用此模式，则它们的尺寸会正比于指定的伸缩比率。 默认状态下，伸缩项目不会收缩至比其最小内容尺寸（最长的英文词或是固定尺寸元素的长度）更小。网页作者可以靠设置min-width或min-height属性来改变这个默认状态. align-self属性 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } flex-start:伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴起始的边。 flex-end:伸缩项目在侧轴终点边的外边距靠住该行在侧轴终点的边 。 center:伸缩项目的外边距盒在该行的侧轴上居中放置。（如果伸缩行的尺寸小于伸缩项目，则伸缩项目会向两个方向溢出相同的量）。 baseline:如果伸缩项目的行内轴与侧轴为同一条，则该值和flex-start等效。其它情况下，该值将参与基线对齐。所有参与该对齐方式的伸缩项目将按下列方式排列：首先将这些伸缩项目的基线进行对齐，随后其中基线至侧轴起点边的外边距距离最长的那个项目将紧靠住该行在侧轴起点的边。 stretch:如果侧轴长度属性的值为auto，则此值会使项目的外边距盒的尺寸在遵照min/max-width/height属性的限制下尽可能接近所在行的尺寸。 博客中有些地方是参考阮老师的文章，再自己作总结的，具体可以参考阮老师的《Flex布局教程》]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的内存问题]]></title>
    <url>%2F2017%2F02%2F21%2Fjavascript-memory%2F</url>
    <content type="text"><![CDATA[一直以来，对于Js的内存空间这部分的知识概念有些模糊，最近在回顾一些知识点的时候，特地的对js的内存这部分知识加深了一下理解，比如基本类型数据和引用类型数据在js内存中是怎么回事？什么是按值传递和按引用传递？以及对作用域和闭包的理解等等。 JavaScript的内存是怎样的？ JavaScript中有两种不同数据类型的值，一种是原始值，另外一种是引用类型值，原始值就是常说的基本数据类型值，包括String、Number、Boolean、Undefined和Null这五大基本数据类型，引用值指的是那些可能由多个指构成的对象，包括Object,Function,Array等类型的值。 JavaScript中的内存也分为栈内存和堆内存。一般来说，栈内存中存放的是存储对象的地址，而堆内存中存放的是存储对象的具体内容。对于原始类型的值而言，其地址和具体内容都存在与栈内存中；而基于引用类型的值，其地址存在栈内存，其具体内容存在堆内存中。堆内存与栈内存是有区别的，栈内存运行效率比堆内存高，空间相对堆内存来说较小，反之则是堆内存的特点。所以将构造简单的原始类型值放在栈内存中，将构造复杂的引用类型值放在堆中而不影响栈的效率。 我们看下下面Js的内存示意图： 12345678910111213141516 var a = 20; var b = 'abc'; var c = true; var d = &#123; m: 20 &#125;``` 可以看出变量a,b,c属于原始数据类型的变量，它们的值都存放在栈内存中，而d是一个对象即属于引用值，栈内存中存放的是它的内存地址，指向堆内存里面具体的一个值。接着我们来看下面的一段代码：```js var a = &#123;n:1&#125;; var b = a; a.x = a = &#123;n:2&#125;; console.log(a.x);// --&gt; undefined console.log(b.x);// --&gt; [object Object] 一开始看这道题，然后看答案，一脸懵逼啊有木有？？？为啥结果输出的是undefined和[object Object]？？？ 了解了Js的变量在内存的存储形式之后，我们一起来解释一下： 1、a是一个引用类型的变量，一开始它在栈内存中的地址是指向堆内存的具体内容{n:1}，接着赋值给b，所以b和a一样，此时都指向对象{n:1}； 12var a = &#123;n:1&#125; ;var b = &#123;n:1&#125; ; 2、接下来a.x = a = {n:2},我们都知道js的赋值运算是从右往左的，但“.”是优先级最高的运算符，所以这段代码先执行了a.x,所以此时对象{n:1}新增加了一个x的属性，并且值是undefined，所以运行到这里a和b都指向了对象{n:1,x:undefined}； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 var a = &#123;n:1，x:undefined&#125; ; var b = &#123;n:1，x:undefined&#125; ;``` 3、接着，依循“从右往左”的赋值运算顺序先执行 a=&#123;n:2&#125; ，这时候，a指向的对象发生了改变，变成了新对象&#123;n:2&#125;;而a.x = a则是对象&#123;n:1，x:undefined&#125;中的属性x指向了对象&#123;n:2&#125;，所以此时指向的对象变成了&#123;n:1,x:&#123;n:2&#125;&#125;。```js var a = &#123;n:2&#125; ; var b = &#123;n:1，x:&#123;n:2&#125;&#125; ;``` 综上所述，我们可以看到最后的运行结果，显然a.x是undefined，b.x是对象&#123;n:2&#125;,用对象的字符串形式[object Object]表示。## Js的内存空间管理JavaScript的内存分配和回收是自动完成的，满足一定条件，就会被垃圾回收器自动回收，下面我们简单的了解下js的内存管理机制。### JavaScript的内存生命周期:1. 分配你所需要的内存2. 使用分配到的内存（读、写）3. 不需要时将其释放、归还```js var num = 10; // 在内存中给数值变量分配空间 alert(num); // 使用内存 num = null; // 使用完毕之后，释放内存空间 var obj = &#123;v:1&#125;; // 内存中存在&#123;v:1&#125;对象，及obj这个引用地址 obj = &#123;value:2&#125;; // 垃圾回收机制自动清理&#123;v:1&#125;，并为新的有用到的&#123;value:2&#125;分配空间``` ### 垃圾回收算法js垃圾回收有两种常见的算法：引用计数和标记清除。#### 引用计数引用计数就是跟踪对象被引用的次数，当一个对象的引用计数为0即没有其他对象引用它时，说明该对象已经无需访问了，因此就会回收其所占的内存，这样，当垃圾回收器下次运行就会释放引用数为0的对象所占用的内存。 &gt; 但引用计数存在一个弊端就是循环引用问题（IE6和IE7就是采用此算法）。循环引用就是指对象A中包含一个指向对象B的引用，而对象B中也包含一个指向对象的引用。```js function problem() &#123; var A = &#123;&#125;; var B = &#123;&#125;; A.a = B; B.a = A;&#125;``` 上面例子可以看出对象A和B存在循环音引用的问题，即两个的引用次数均为2，它们在运行之后依然存在，并且引用次数永远不为0，如果这个函数被多次调用，就有可能引起内存泄漏问题。为了解决循环引用的问题，还有一种方法就是可以实现垃圾回收，那就是标记清除法。#### 标记清除标记清除法是现代浏览器常用的一种垃圾收集方式，当变量进入环境（即在一个函数中声明一个变量）时，就将此变量标记为“进入环境”，进入环境的变量是不能被释放，因为只有执行流进入相应的环境，就可能会引用它们。而当变量离开环境时，就标记为“离开环境”。垃圾收集器在运行时会给储存在内存中的所有变量加上标记，然后会去掉环境中的变量以及被环境中的变量引用的变量的标记，当执行完毕那些没有存在引用无法访问的变量就被加上标记，最后垃圾收集器完成清除工作，释放掉那些打上标记的变量所占的内存。&gt; 标记清除之所以不存在循环引用的问题，是因为当函数执行完毕之后，对象A和B就已经离开了所在的作用域，此时两个变量被标记为“离开环境”，等待被垃圾收集器回收，最后释放其内存。### 管理内存使用具备垃圾收集机制的语言编写程序，开发人员一般都不必担心内存管理的问题。但JavaScript在进行内存管理以及垃圾收集时面临的问题还是有些不同。出于安全方面的考虑，系统分配给浏览器的可用内存数量通常要比分配给桌面应用程序的少，防止JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。 因此为了确保占用最少的内存可以让页面获取更好的性能。优化内存占用的最佳方式就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用，即解除引用。这一做法适用于大多全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。（具体请阅读《JavaScript高级程序设计》第四章）可以分析以下代码：```js function createPerson(name)&#123; var localPerson = new Object(); localPerson.name = name; return localPerson; &#125; var globalPerson = createPerson("Junga"); globalPerson = null;//手动解除全局变量的引用``` 在这个🌰中，变量globalPerson取得了createPerson()函数的返回的值。在createPerson()的内部创建了一个局部变量localPerson并添加了一个name属性。由于localPerson在函数执行完毕之后就离开执行环境，因此会自动解除引用，而对于全局变量来说则需要我们手动设置null，解除引用。&gt; 不过，解除一个值的引用并不意味着自动回收该值所占用的内存，解除引用真正的作用是让值脱离执行环境，以便垃圾收集器下次运行时将其收回。## 内存优化&gt; 对于全局变量，JavaScript不能确定它在后面不能够被用到，所以它会从声明之后就一直存在于内存中，直至手动释放或者关闭页面/浏览器，这就导致了某些不必要的内存消耗。我们可以进行以下的优化:### 立即执行函数的运用```js ;(function(window, $, undefined) &#123; // 主业务代码 &#125;)(window, jQuery); 立即执行函数的作用就是建立一个独立的作用域，其一是为了防止全局污染，同时也可以防止过多的定义全局变量造成的内存回收问题。如果你的某些变量真的需要一直存在可以通过上面的方法挂载在window下。同样，你也可以传入jQuery进行使用。 手动解除变量的引用 12var obj = &#123;a:1,b:2,c:3&#125;;obj = null; 使用回调 除了使用闭包进行内部变量访问，回调函数也有这个功能。 1234567function getData(callback) &#123; var data = 'Junga'; callback(data);&#125;getData(function(data) &#123; console.log(data);&#125;); 回调函数是一种后续传递风格(Continuation Passing Style, CPS)的技术，这种风格的程序编写将函数的业务重点从返回值转移到回调函数中去。而且其相比闭包的好处也不少： 如果传入的参数是基础类型（如字符串、数值），回调函数中传入的形参就会是复制值，业务代码使用完毕以后，更容易被回收； 通过回调，我们除了可以完成同步的请求外，还可以用在异步编程中，这也就是现在非常流行的一种编写风格； 回调函数自身通常也是临时的匿名函数，一旦请求函数执行完毕，回调函数自身的引用就会被解除，自身也得到回收。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于js事件循环的那点一知半解]]></title>
    <url>%2F2017%2F02%2F17%2Fevent-Loop%2F</url>
    <content type="text"><![CDATA[起源 最近在回顾一些知识点，也解惑了一些之前不懂的知识点，在这个过程中也饶有兴致的搞了一个个人博客，现在看来还不错，即可以总结记录一些知识点，又可以分享，虽然现在是给自己的看到哈哈哈~~~ 其中在网上看到了一道面试题，跟之前去某公司给的一道面试题一毛一样，涉及到的是长数组递归可能造成js的堆栈溢出，而后又从堆栈溢出引申了解到了JS的事件循环，总算是对此有了一知半解。 先看看下面这道面试题： 如果 list 很大，下面的这段递归代码会造成堆栈溢出。如果在不改变递归模式的前提下修善这段代码: var list = readHugeList(); var nextListItem = function() { var item = list.pop(); if (item) { // process the list item... nextListItem(); } }; 之前是刚毕业不久去某公司碰到的一道面试题，当时对js的一些知识掌握的不是很深刻，这道题完全不知道怎么去解决？后面这道就没写，最后面试以失败告终。不过那次之后也发现自己的不足，任重而道远啊。其他废话不多说了，进入正题吧！ 上面那道题的答案是加一个setTimeout的定时器： var list = readHugeList(); var nextListItem = function() { var item = list.pop(); if (item) { // process the list item... setTimeout( nextListItem, 0); } }; 之后还是有些困惑不解，后面查了一些资料之后，原来涉及到了JavaScript的事件循环机制。 JS的事件循环机制 我们都知道，JS是单线程的编程语言，即在js运行时，所有的任务是一个队列，只有前一个任务完成了，下一个任务才会继续执行。因此，如果前面一个任务耗时很长，那么下一个任务就要长时间等待，可想而知，这样的处理任务效率非常低。 JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。 由此，JavaScript的运行机制可以简单理解为一个主线程和一个任务队列，脚本运行时先运行主线程，主线程运行完后，从”任务队列”中读取事件，运行任务队列的任务，这个过程是循环不断的，又称Event Loop（事件循环）。注意只要主线程的任务没有运行完，异步队列中的任务永远也无法运行，所以会导致浏览器出现假死的情况。我们可以看一下图解（转引自阮老师的JavaScript 运行机制详解：再谈Event Loop）。 解决 所谓的事件循环不是单纯只有JS的事件类型去触发，类似setTimeout开启的延时线程，当主线程运行之后，在一定的时间会触发setTimeout的异步任务，此时任务便从消息队列移除进入主线程完成执行，所以setTimeout亦可以看做是由时间的长短来定时触发的一种事件. 我们来看下面的代码： console.log('a'); setTimeout(function(){ console.log('b'); },0); console.log('c'); 上述运行结果依次输出的是 acb；原因是js执行时同步加以上任务放入主线程，而遇到setTimeout之后开启了一个延时线程，进入了异步任务队列，等到主线程的任务都完成之后，再读取任务队列，所以输出的结果是acb。 需要进一步解释的是：这里的零延迟不是说setTimeout会被立刻执行，是说等到主线程执行完成，并且任务队列中没有其他任务时，setTimeout的回调函数才会被执行，最重要的一点就是setTimeout设置的时间并非回调函数会在这个时间间隔之后立即运行，仅仅表示的是最少时间而非确切的时间，因为主线程任务需要执行完成为空时，才会处理任务队列的消息处理即回调函数，所以setTimeout执行回调函数所等待的时间比它设定的时间参数要长。 现在我们可以回过头去解释刚开始那道用setTimeout来解决内存溢出的面试题: 在没有用setTimeout进行递归时，当数组过大，不断进行递归调用，主线程的任务数量会不断叠加，当达到一定大小就会造成堆栈溢出，而当递归函数放到setTimeout进行异步执行，此时相当于开了另外一个延时线程，主线程就负责调用setTimeout这个异步线程执行任务就可以，一执行完成就释放，就不会造成堆栈溢出。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS之清除浮动]]></title>
    <url>%2F2017%2F02%2F16%2Fcss-clearFloat%2F</url>
    <content type="text"><![CDATA[面试的时候，关于清除浮动的问题经常会被考察，一开始对清除浮动了解不深，只知道css有个clear属性。在平时开发中也经常会用到float布局方式，之前因为了解不深，所以使用这种布局的时候经常出现问题。后面查找资料才发现原来清除浮动后面大有学问，了解清除浮动有利于我们对布局的开发，下面是对了解之后作出的一些总结，可能总结的不全面。 在了解清除浮动之前，先看下什么是BFC。 了解BFC 首先看看W3C对BFC是怎么定义的： Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents. In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse. In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats). 翻译过来就是： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的块级格式化上下文。 在一个块级格式化上下文里，盒子从包含块的顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。两个相邻的块级盒子的垂直外边距会发生叠加。 在块级格式化上下文中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘），即使存在浮动也是如此，除非这个盒子创建一个新的块级格式化上下文。 BFC就是“块级格式化上下文”的意思，创建了BFC的元素就是一个独立的盒子，不过只有Block-level box可以参与创建BFC，它规定了内部的Block-level Box如何布局，并且与这个独立盒子里的布局不受外部影响，当然它也不会影响到外面的元素。 BFC的特性 内部的Box会在垂直方向，从顶部开始一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生叠加 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box叠加。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。 计算BFC的高度时，浮动元素也参与计算。 触发BFC的属性 float 除了none以外的值 overflow 除了visible 以外的值（hidden，auto，scroll ） display (table-cell，table-caption，inline-block, flex, inline-flex) position值为（absolute，fixed） 清除浮动 在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。 清除浮动的本质就是让元素标签闭合，即触发其BFC,所以以上可以触发BFC的可以清除浮动,此外css还有一个clear属性也可以清除浮动 方法 方法一：使用额外标签法，即使用带clear属性的空元素 优点：简单，代码少，浏览器兼容性好。 缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394.box &#123; background-color: gray; border: solid 1px black; &#125;.box img &#123; float: left; &#125;.box p &#123; float: right; &#125;.clear &#123; clear: both; &#125;&lt;div class="box"&gt; &lt;img src="news-pic.jpg" /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;div class="clear"&gt;&lt;/div&gt;&lt;/div&gt;``` 方法二：利用CSS的overflow属性给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。明显的缺点是当容器内部的内容过多时会被隐藏``` html.box &#123; background-color: gray; border: solid 1px black; overflow: hidden; *zoom: 1; &#125;.box img &#123; float: left; &#125;.box p &#123; float: right; &#125;&lt;div class="box"&gt; &lt;img src="news-pic.jpg" /&gt; &lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;``` 方法三：给浮动的元素的容器添加浮动给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。方法四：给父元素定高父容器因为子元素浮动造成高度撑不开，可以给父元素定高度，缺点明显是当父容器高度固定了，不够灵活。方法五：使用css的:after伪元素（现在项目中清除浮动就是采用这种方法，兼容性跟友好性都比较好）after伪元素和zoom：1结合可以解决当前绝大多数浏览器浮动问题，zoom:1可以触发IE的hasLayout，具体实现代码如下：``` html.box &#123; background-color: gray; border: solid 1px black; overflow: hidden; *zoom: 1; &#125;.box img &#123; float: left; &#125;.box p &#123; float: right; &#125;.clearfix:after&#123; content: "."; display: block; height: 0; clear: both; visibility: hidden; &#125;.clearfix &#123; /* 触发 hasLayout */ zoom: 1; &#125;&lt;div class="box clearfix"&gt; &lt;img src="news-pic.jpg" /&gt; &lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 总结 通过上面的例子，清除浮动的方法可以分成两类： 一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。 二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一个个人博客]]></title>
    <url>%2F2017%2F02%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[最近一直有个想搞个个人博客玩玩的想法，今天在网上看到一个静态博客框架Hexo，于是看教程学着搭建了一个，现在看起来很成功，哈哈！开启我的博客之旅吧！ 安装前系统所需要的工具 1、Git Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Hexo就是将你的博客项目上传托管到git,通过github来访问你的个人博客了。 2、Node 因为Hexo是一款基于Node.js的静态博客框架，所以我们还需要安装好它。 3、Hexo 安装好Git和Node.js之后，轮到我们今天的主角登场了~先打开Git Bash，然后输入下面这条命令来安装Hexo： $ npm install hexo-cli -g 安装完输入以下命令查看版本信息： $ hexo -v 如果出现类似以下内容的则安装成功 hexo: 3.2.2 hexo-cli: 1.0.2 os: Darwin 16.1.0 darwin x64 http_parser: 2.7.0 node: 6.9.1 v8: 5.1.281.84 uv: 1.9.1 zlib: 1.2.8 ares: 1.10.1-DEV icu: 57.1 modules: 48 openssl: 1.0.2j 接下来就可以用Hexo愉快的zhuangbility了！！！ 创建属于自己的博客 初始化hexo创建博客模板 在本地创建一个文件夹，比如blog,进入文件夹执行以下命令： $ hexo init 执行完成之后可以在blog文件下看到博客相关的配置文件~~~ 配置github 建立Repository，建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，然后与本地blog建立关联， 关联之前首先配置一下blog根目录下的_config.yml文件： deploy: type: git repo: 你创建的博客所在的仓库github路径 branch: master 然后执行以下命令：其中hexo g是生成静态页面至public目录，hexo deploy #将.deploy目录部署到GitHub $ npm install hexo-deployer-git --save $ hexo g $ hexo d 一些常用的命令： hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 至此，你可以打开你的个人博客路径username.github.io，就可以看到你的博客了。 更加详细的教程前往hexo的中文官网查看]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
